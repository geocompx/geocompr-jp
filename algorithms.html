<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 11 スクリプト、アルゴリズム、関数 | Geocomputation with R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="必須パッケージ この章では、主に Base R を使用するため、必要なソフトウェアは最小限である。 これから開発するアルゴリズムの結果を確認するために sf パッケージだけを使用する。 Chapter 2 で紹介した地理クラスと、それを使ってさまざまな入力ファイル形式を表現する方法 (Chapter 8 参照) について理解していることを前提にしている。  11.1 イントロダクション...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 11 スクリプト、アルゴリズム、関数 | Geocomputation with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://r.geocompx.org/jp/algorithms.html">
<meta property="og:image" content="https://r.geocompx.org/jp/images/cover2.png">
<meta property="og:description" content="必須パッケージ この章では、主に Base R を使用するため、必要なソフトウェアは最小限である。 これから開発するアルゴリズムの結果を確認するために sf パッケージだけを使用する。 Chapter 2 で紹介した地理クラスと、それを使ってさまざまな入力ファイル形式を表現する方法 (Chapter 8 参照) について理解していることを前提にしている。  11.1 イントロダクション...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 11 スクリプト、アルゴリズム、関数 | Geocomputation with R">
<meta name="twitter:description" content="必須パッケージ この章では、主に Base R を使用するため、必要なソフトウェアは最小限である。 これから開発するアルゴリズムの結果を確認するために sf パッケージだけを使用する。 Chapter 2 で紹介した地理クラスと、それを使ってさまざまな入力ファイル形式を表現する方法 (Chapter 8 参照) について理解していることを前提にしている。  11.1 イントロダクション...">
<meta name="twitter:image" content="https://r.geocompx.org/jp/images/cover2.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.10/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.10/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.10/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><meta name="citation_title" content="Chapter 11 スクリプト、アルゴリズム、関数 | Geocomputation with R">
<meta name="citation_author" content="Robin Lovelace">
<meta name="citation_author" content="Jakub Nowosad">
<meta name="citation_author" content="Jannes Muenchow">
<meta name="citation_publication_date" content="2019">
<meta name="citation_isbn" content="9780203730058">
<link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">
<script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.2.2/leaflet.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDC2S0ZNH5"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VDC2S0ZNH5');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ようこそ</a></li>
<li><a class="" href="foreword-1st-edition.html">序文 (第 1 版)</a></li>
<li><a class="" href="forward-2nd-edition.html">序文 (第 2 版)</a></li>
<li><a class="" href="preface.html">序文</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> はじめに</a></li>
<li class="book-part">基本機能</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> 地理データと R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> 属性データ操作</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> 空間データ操作</a></li>
<li><a class="" href="geometry-operations.html"><span class="header-section-number">5</span> ジオメトリ演算</a></li>
<li><a class="" href="raster-vector.html"><span class="header-section-number">6</span> ラスタとベクタの相互作用</a></li>
<li><a class="" href="reproj-geo-data.html"><span class="header-section-number">7</span> 地理データの再投影</a></li>
<li><a class="" href="read-write.html"><span class="header-section-number">8</span> 地理データI/O</a></li>
<li class="book-part">拡張機能</li>
<li><a class="" href="adv-map.html"><span class="header-section-number">9</span> R で地図を作成</a></li>
<li><a class="" href="gis.html"><span class="header-section-number">10</span> GIS ソフトウェアへのブリッジ</a></li>
<li><a class="active" href="algorithms.html"><span class="header-section-number">11</span> スクリプト、アルゴリズム、関数</a></li>
<li><a class="" href="spatial-cv.html"><span class="header-section-number">12</span> 統計的学習</a></li>
<li class="book-part">応用</li>
<li><a class="" href="transport.html"><span class="header-section-number">13</span> 交通解析</a></li>
<li><a class="" href="location.html"><span class="header-section-number">14</span> 商圏分析</a></li>
<li><a class="" href="eco.html"><span class="header-section-number">15</span> 生態学</a></li>
<li><a class="" href="conclusion.html"><span class="header-section-number">16</span> 結論</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompx/geocompr">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="algorithms" class="section level1" number="11">
<h1>
<span class="header-section-number">11</span> スクリプト、アルゴリズム、関数<a class="anchor" aria-label="anchor" href="#algorithms"><i class="fas fa-link"></i></a>
</h1>
<div id="prerequisites-11" class="section level2 unnumbered">
<h2>必須パッケージ<a class="anchor" aria-label="anchor" href="#prerequisites-11"><i class="fas fa-link"></i></a>
</h2>
<p>この章では、主に Base R を使用するため、必要なソフトウェアは最小限である。
これから開発するアルゴリズムの結果を確認するために <strong>sf</strong> パッケージだけを使用する。
Chapter <a href="spatial-class.html#spatial-class">2</a> で紹介した地理クラスと、それを使ってさまざまな入力ファイル形式を表現する方法 (Chapter <a href="read-write.html#read-write">8</a> 参照) について理解していることを前提にしている。</p>
</div>
<div id="intro-algorithms" class="section level2" number="11.1">
<h2>
<span class="header-section-number">11.1</span> イントロダクション<a class="anchor" aria-label="anchor" href="#intro-algorithms"><i class="fas fa-link"></i></a>
</h2>
<p>Chapter <a href="intro.html#intro">1</a> は、ジオコンピュテーションは既存のツールを使うだけでなく、「共有可能な R スクリプトや関数の形で」新しいツールを開発することが重要であることを示した。
本章では、これらの再現性のあるコードの構成要素について学ぶ。
また、Chapter <a href="gis.html#gis">10</a> で使用されているような低レベルの幾何学的アルゴリズムも紹介する。
これを読めば、このようなアルゴリズムの仕組みを理解し、複数のデータセットに対して、多くの人が、何度も使えるようなコードを書くことができるようになるはずである。
本章だけでは、熟練したプログラマになることはできない。
プログラミングは難しく、十分な練習が必要である <span class="citation">(<a href="references.html#ref-abelson_structure_1996">Abelson, Sussman, and Sussman 1996</a>)</span> :</p>
<blockquote>
<p>プログラミングをそれ自体の知的活動として理解するためには、プログラミングに目を向けなければならないし、プログラムを読み、書かなければならない。</p>
</blockquote>
<p>しかし、プログラミングを学ぶ強い理由がある。
この章では、プログラミングそのものを教えるわけではない。プログラミングについては、<span class="citation">Wickham (<a href="references.html#ref-wickham_advanced_2019">2019</a>)</span>、<span class="citation">Gillespie and Lovelace (<a href="references.html#ref-gillespie_efficient_2016">2016</a>)</span>、<span class="citation">Xiao (<a href="references.html#ref-xiao_gis_2016">2016</a>)</span> を推奨する。これらの書籍は R や他の言語について教えてくれる。また、地理データに焦点を当て、プログラミング能力を伸ばすための基礎を作ることができる。</p>
<p>本章は、再現性の重要性について、例を示しながら強調していきたい。
再現性の利点は、他の人があなたの研究を複製することを可能にするだけではない。
再現性のあるコードは、一度だけ実行されるように書かれたコードよりも、計算効率、スケーラビリティ (より大きなデータセットに対して実行するコードの能力)、適応やメンテナンスのしやすさなど、あらゆる面で優れていることが多いのである。</p>
<p>スクリプトは、再現可能な R コードの基礎であり、このトピックは、Section <a href="algorithms.html#scripts">11.2</a> でカバーされている。
アルゴリズムは、Section <a href="algorithms.html#geometric-algorithms">11.3</a> で説明されているように、一連のステップを使用して入力を変更し、その結果、出力を得るためのレシピである。
共有と再現を容易にするために、アルゴリズムを関数に配置することができる。
それが、Section <a href="algorithms.html#functions">11.4</a> のトピックである。
ポリゴンの重心を求める例で、これらの概念を結びつけていこう。
Chapter <a href="geometry-operations.html#geometry-operations">5</a> で、重心の関数 <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> をすでに紹介したが、この例は、一見単純な操作が比較的複雑なコードの結果であることを強調し、次の観察を保証する <span class="citation">(<a href="references.html#ref-wise_gis_2001">Wise 2001</a>)</span> 。</p>
<blockquote>
<p>空間データの問題で最も興味深いのは、人間にとっては些細なことに見えることが、コンピュータにとっては驚くほど難しいということである。</p>
</blockquote>
<p>この例は、<span class="citation">Xiao (<a href="references.html#ref-xiao_gis_2016">2016</a>)</span> にならい、「世の中にあるものを複製するのではなく、世の中のものがどのように機能しているかを示す」という本章の第二の目的も反映している。</p>
</div>
<div id="scripts" class="section level2" number="11.2">
<h2>
<span class="header-section-number">11.2</span> スクリプト<a class="anchor" aria-label="anchor" href="#scripts"><i class="fas fa-link"></i></a>
</h2>
<p>パッケージで配布される関数が R コードの構成要素だとすれば、スクリプトはそれらを論理的な順序でまとめる接着剤となる。
スクリプトとは、再現可能なワークフローを作り出す目的で、手動または <strong>targets</strong> などの自動化ツールで保存・実行される <span class="citation">(<a href="references.html#ref-landau_targets_2021">Landau 2021</a>)</span>。
プログラミングの初心者にとってスクリプトは敷居が高く聞こえるかもしれないが、単なるプレーンテキストファイルである。
スクリプトは、通常はその言語を表す拡張子で保存される。例えば、Python は <code>.py</code>、Rust は <code>.rs</code> である。
R スクリプトは一般に、<code>.R</code> 拡張子で保存され、実行内容を反映した名前が付けられる。
例として、この本のリポジトリの <code>code</code> フォルダに格納されているスクリプトファイル <a href="https://github.com/geocompx/geocompr/tree/main/code/11-hello.R"><code>11-hello.R</code></a> がある。
<code>11-hello.R</code> は、次の 2 行のコードが含まれているだけの簡単なスクリプトで、そのうち 1 行はコメントである。</p>
<div class="sourceCode" id="cb402"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Aim: provide a minimal R script</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="st">"Hello geocompr"</span><span class="op">)</span></span></code></pre></div>
<p>このスクリプトの中身は、とりたててスゴいものではないが、「スクリプトは複雑である必要はない」という点を示している。
保存されたスクリプトは、<code><a href="https://rdrr.io/r/base/source.html">source()</a></code> を使って、その全体を呼び出したり、実行したりすることができる。
このコマンドの出力から、コメント行は無視され、<code><a href="https://rdrr.io/r/base/print.html">print()</a></code> コマンドが実行されることがわかる。</p>
<div class="sourceCode" id="cb403"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"code/11-hello.R"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Hello geocompr"</span></span></code></pre></div>
<p>以下のように <code>bash</code> や <code>PowerShell</code> などのシステムコマンドラインシェルから R スクリプトを呼び出すこともできる。</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb404-1"><a href="algorithms.html#cb404-1" tabindex="-1"></a><span class="ex">Rscript</span> code/11-hello.R</span></code></pre></div>
<p><code>RScript</code> 実行可能ファイルが <a href="https://www.reddit.com/r/Rlanguage/comments/zaovly/is_anybody_able_to_run_a_r_script_in_powershell/">設定</a>されていれば、システムのシェルで <code>Hello geocompr</code> と表示される。
スクリプトファイルに何を書くべきで何を書くべきではないかについて厳密なルールがあるわけではない。壊れた再現性のないコードになることもよくあるので、テストが必要である。
有効な R を含まないコード行は、エラーを防ぐため、行頭に <code>#</code> を追加してコメントアウトする必要がある。<code>11-hello.R</code> スクリプトの 1 行目を参照。
守るべき基本的ルールもある。</p>
<ul>
<li>順番に書く。映画の脚本と同じように、スクリプトも「設定」「データ処理」「結果保存」といった明確な順番が必要である (映画でいうところの「始まり」「中間」「終わり」にほぼ相当する)</li>
<li>他の人 (と未来の自分) が理解できるように、スクリプトにコメントを追加してみよう。
これは、例えば、RStudio で、「折りたたみ可能な」コードセクションの見出しを作成するショートカット <code>Ctrl+Shift+R</code> を使って行うことができる</li>
<li>特に、スクリプトは再現可能であるべきである。どんなコンピュータでも動作する自己完結型のスクリプトは、調子の良い日に自分のコンピュータでしか動作しないスクリプトよりも有用である。
これには、必要なパッケージを最初に添付し、データを永続的なソース (信頼できるウェブサイトなど) から読み込み、前のステップが実行されたことを確認することが含まれる。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
前のステップは、コメントまたは &lt;code&gt;if(!exists("x")) source("x.R")&lt;/code&gt; のような if 文で参照できる (オブジェクト &lt;code&gt;x&lt;/code&gt; が見つからない場合、スクリプトファイル &lt;code&gt;x.R&lt;/code&gt; を実行する)。&lt;/p&gt;'><sup>79</sup></a>
</li>
</ul>
<p>パッケージ化しないかいぎり R スクリプトで再現性を強制するのは難しいが、それを助けるツールはある。
RStudio は、デフォルトで R スクリプトを「コードチェック」し、不具合のあるコードに赤い波線を引く (下図参照)。
<strong>repex</strong> パッケージは、再現性のためのツールである。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:codecheck"></span>
<img src="images/codecheck.png" alt="RStudio でのコード確認の様子。この例は 11-centroid-alg.R スクリプトの 19 行目のカッコが閉じられていないことを示している。" width="100%"><p class="caption">
FIGURE 11.1: RStudio でのコード確認の様子。この例は 11-centroid-alg.R スクリプトの 19 行目のカッコが閉じられていないことを示している。
</p>
</div>

<div class="rmdnote">
再現性に役立つのは <strong>reprex</strong> パッケージである。
このパッケージの <code>reprex()</code> 関数は、R コードが再現可能かどうかを確認し、GitHub などのサイトで交流する際に使えるマークダウンを生成する。
詳細は reprex.tidyverse.org を参照。
</div>
<p>
このセクションの内容は、あらゆるタイプの R スクリプトに適用できる。
ジオコンピュテーションのためのスクリプトで特に考慮すべき点は、GDAL など外部ライブラリへの依存が多い点である。実際、Chapter <a href="read-write.html#read-write">8</a> のデータ入出力では GDAL をたくさん使用した。
GIS ソフトウェアの依存は、Chaptger <a href="gis.html#gis">10</a> で解説したようにより多くの特別なジオアルゴリズムを実行するために必要になる。
地理データを扱うスクリプトは、入力データセットが特定のファイル形式であることを必要とする。
このような依存関係は、スクリプトのコメントとして、またはスクリプトの一部であるプロジェクトの他の場所でコメントするか、<strong>renv</strong> や Docker などで依存性として記述するべきである。</p>
<p>「保守的」プログラミング技術と適切なエラーメッセージは、要件が満たされていない時に依存性を確認し、ユーザと対話する時間を節約する。
R では <code>if ()</code> で表される If 文を使用し、特定の条件が揃った時のみにメッセージを送ったりコードを実行するようにコードを書く。
以下のコード例は、特定のファイルがない場合にユーザにメッセージを送る (訳註: メッセージに日本語を使わないことを推奨する。)。</p>
<div class="sourceCode" id="cb405"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/files.html">file.exists</a></span><span class="op">(</span><span class="st">"required_geo_data.gpkg"</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/message.html">message</a></span><span class="op">(</span><span class="st">"No file, required_geo_data.gpkg is missing!"</span><span class="op">)</span></span>
<span><span class="op">}</span> </span>
<span><span class="co">#&gt; No file, required_geo_data.gpkg is missing!</span></span></code></pre></div>
<p>このスクリプトが行う作業は、以下の再現例で示されている。このスクリプトは、<code>poly_mat</code> という、長さ 9 単位の辺を持つ正方形 (この意味は次のセクションで明らかになる) という前提条件のオブジェクトに対して動作する。
この例では、インターネットに接続していることを前提に、<code><a href="https://rdrr.io/r/base/source.html">source()</a></code> が URL (ここでは短縮版を使用) で動作することを示している。
そうでない場合は、<a href="https://github.com/geocompx/geocompr">github.com/geocompx/geocompr</a> からダウンロードできる <code>geocompr</code> フォルダのルートディレクトリから R を実行していると仮定して、<code>source("code/11-centroid-alg.R")</code> で同じスクリプトを呼び出すことができる。</p>
<div class="sourceCode" id="cb406"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">9</span>, <span class="fl">9</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">9</span>, <span class="fl">9</span>, <span class="fl">0</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># geocompr リポジトリの code/11-centroid-alg.R の短い URL</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"https://t.ly/0nzj"</span><span class="op">)</span></span></code></pre></div>
<pre><code>#&gt; [1] "The area is: 81"
#&gt; [1] "The coordinates of the centroid are: 4.5, 4.5"</code></pre>
</div>
<div id="geometric-algorithms" class="section level2" number="11.3">
<h2>
<span class="header-section-number">11.3</span> 幾何学的アルゴリズム<a class="anchor" aria-label="anchor" href="#geometric-algorithms"><i class="fas fa-link"></i></a>
</h2>
<p>アルゴリズムは、コンピュータにおける料理のレシピに相当するものと理解することができる。
入力に対して実行されると、有用または美味しい出力が得られる指示の完全なセットである。
入力とは、料理においては小麦粉や砂糖などの食材で、アルゴリズムの場合はデータと入力パラメータとなる。
美味しいケーキはレシピの結果であるのと同様に、アルゴリズムの成功は環境や社会的に利点のある出力となりうる。
具体的なケーススタディに入る前に、アルゴリズムとスクリプト (Section <a href="algorithms.html#scripts">11.2</a> ) や関数 (Section <a href="algorithms.html#functions">11.4</a> で説明するように、アルゴリズムを一般化し、他でも使えるようにしたり簡単にする) の関係について簡単に説明する。</p>
<p>「アルゴリズム」という言葉は、西暦825年のバグダッドで出版されたされた、初期の数学教科書に端を発している。
この本はラテン語に翻訳され、人気を博しただけでなく、著者の名字である <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">al-Khwārizmī</a> が「科学用語として不滅の名声を得て、Alchoarismi、Algorismi、そして最終的には algorithm になった」 <span class="citation">(<a href="references.html#ref-bellos_alex_2011">Bellos 2011</a>)</span> 。
コンピュータ時代には、アルゴリズムは、問題を解決する一連のステップを指し、その結果、あらかじめ定義された出力が得られる。
入力は、適切なデータ構造で正式に定義されなければならない <span class="citation">(<a href="references.html#ref-wise_gis_2001">Wise 2001</a>)</span>。
アルゴリズムは、多くの場合、コードで実装される前に、処理の目的を示すフローチャートや疑似コードとして開始される。
使い勝手をよくするために、一般的なアルゴリズムは関数内にパッケージ化されていることが多く、(関数のソースコードを見ない限り) 一部または全部の手順が隠されている場合がある (Section <a href="algorithms.html#functions">11.4</a> を参照)。</p>
<p>Chapter <a href="gis.html#gis">10</a> で見たような ジオアルゴリズムは、地理的なデータを取り込み、一般的には地理的な結果を返すアルゴリズムである (同じものを表す別の用語として、<u>GIS アルゴリズム</u>、<u>幾何学的アルゴリズム</u>がある)。
簡単そうに聞こえるだろうが、このテーマは奥が深く、<u>計算幾何学</u>という学問分野全体がその研究に専念している <span class="citation">(<a href="references.html#ref-berg_computational_2008">Berg et al. 2008</a>)</span>。このテーマに関する書籍も多数出版されている。
例えば、<span class="citation">O’Rourke (<a href="references.html#ref-orourke_computational_1998">1998</a>)</span> は、再現可能で自由に利用できる C コードを用いて、徐々に難しくなる幾何学的アルゴリズムの範囲を紹介している。</p>
<p>幾何学的アルゴリズムの例としては、ポリゴンの重心を求めるものがある。
重心の計算には多くのアプローチがあり、中には特定のタイプの<a href="https://en.wikipedia.org/wiki/Centroid">空間データ</a>に対してのみ機能するものもある。
本節では、視覚化しやすいアプローチを選択する。ポリゴンを多くの三角形に分割し、それぞれの重心を求める。このアプローチは、他の重心アルゴリズムと並んで <span class="citation">Kaiser and Morin (<a href="references.html#ref-kaiser_algorithms_1993">1993</a>)</span> によって議論された <span class="citation">(簡単な説明は <a href="references.html#ref-orourke_computational_1998">O’Rourke 1998</a>)</span>。
コードを書く前に、このアプローチをさらに個別のタスクに分解するのに役立つ (以降、ステップ 1 からステップ 4 と呼ぶが、これらは模式図や疑似コード として提示すこともできる)。</p>
<ol style="list-style-type: decimal">
<li>ポリゴンを連続した三角形に分割する</li>
<li>各三角形の重心を求める</li>
<li>それぞれの三角形の面積を求める</li>
<li>三角形の中心点の面積加重平均を求める</li>
</ol>
<p>一見、簡単そうに見えるが、言葉をコードに変換するには、入力に制約がある場合でも、試行錯誤を繰り返しながら作業を進める必要がある。
このアルゴリズムは、180°以上の内角を持たない<u>凸ポリゴン</u>に対してのみ動作し、星形は使用できない (パッケージの <strong>decido</strong> と <strong>sfdct</strong> は外部ライブラリを使用して非凸ポリゴンを三角測量できる。<a href="https://geocompx.org/">geocompx.org</a> の <a href="https://geocompx.github.io/geocompkg/articles/algorithm.html">algorithm</a> vignetteに示されている。)。</p>
<p>ポリゴンの最も単純なデータ構造は、x と y の座標の行列で、各行はポリゴンの境界を順にたどる頂点を表し、最初と最後の行は同一である <span class="citation">(<a href="references.html#ref-wise_gis_2001">Wise 2001</a>)</span>。
今回は、<em>GIS Algorithms</em> <span class="citation">(<a href="references.html#ref-xiao_gis_2016">Xiao 2016</a> Python コードは <a href="https://github.com/gisalgs/geom">github.com/gisalgs</a> を参照)</span> の例を参考に、Figure <a href="algorithms.html#fig:polymat">11.2</a> に示すように、5 つの頂点を持つポリゴンを Base R で作成する。</p>
<div class="sourceCode" id="cb408"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># ポリゴンを表現する行列を作成</span></span>
<span><span class="va">x_coords</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">12</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y_coords</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">15</span>, <span class="fl">20</span>, <span class="fl">10</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">poly_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">x_coords</span>, <span class="va">y_coords</span><span class="op">)</span></span></code></pre></div>
<p>これで、例となるデータセットができたので、上記のステップ 1 に着手する準備が整った。
以下のコードでは、1 つの三角形 (<code>T1</code>) を作成して、この方法を示している。また、 <a href="https://math.stackexchange.com/a/1702606">数式</a> <span class="math inline">\(1/3(a + b + c)\)</span> (<span class="math inline">\(a\)</span> から <span class="math inline">\(c\)</span> は三角形の頂点を表す座標) に基づいて重心を計算するステップ 2 も示している。</p>
<div class="sourceCode" id="cb409"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 原点を作成:</span></span>
<span><span class="va">Origin</span> <span class="op">=</span> <span class="va">poly_mat</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span></span>
<span><span class="co"># 三角形の行列を作成:</span></span>
<span><span class="va">T1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span> </span>
<span><span class="va">C1</span> <span class="op">=</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span> <span class="op">+</span> <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>,<span class="op">]</span> <span class="op">+</span> <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>,<span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:polymat"></span>
<img src="figures/polymat-1.png" alt="ポリゴン重心計算問題。" width="100%"><p class="caption">
FIGURE 11.2: ポリゴン重心計算問題。
</p>
</div>
<p>ステップ 3 では、各三角形の面積を求めるので、大きな三角形の不釣り合いな影響を考慮した<u>加重平均</u>を計算する。
三角形の面積を計算する公式は次の通りである <span class="citation">(<a href="references.html#ref-kaiser_algorithms_1993">Kaiser and Morin 1993</a>)</span>。</p>
<p><span class="math display">\[
\frac{A_x ( B_y − C_y ) + B_x ( C_y − A_y ) + C_x ( A_y − B_y )}{ 2 }
\]</span></p>
<p>ここで、<span class="math inline">\(A\)</span> から <span class="math inline">\(C\)</span> は三角形 <code>T1</code> の 3 点、<span class="math inline">\(x\)</span> と <span class="math inline">\(y\)</span> は x と y の次元を指す。
この式を、三角形の行列表現のデータを扱う R コードに翻訳すると、次のようになる (関数 <code><a href="https://rdrr.io/r/base/MathFun.html">abs()</a></code> は、正の結果を保証する)。</p>
<div class="sourceCode" id="cb410"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 行列 T1 で表される三角形の面積を計算</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span></span>
<span><span class="co">#&gt; [1] 85</span></span></code></pre></div>
<p>このコードチャンクは正しい結果を出力する。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
この結果は、以下の式で確認することができる (ベースが水平であると仮定している)。
面積は、ベース幅×高さの半分となる。&lt;span class="math inline"&gt;\(A = B * H / 2\)&lt;/span&gt;.
この場合、&lt;span class="math inline"&gt;\(10 * 10 / 2 = 50\)&lt;/span&gt;.&lt;/p&gt;'><sup>80</sup></a>
このコードは不格好で、別の三角行列で実行する場合、再入力しなければならない点が問題である。
より一般化するために、このコードを Section <a href="algorithms.html#functions">11.4</a> で関数に変換する方法を見てみよう。</p>
<p>ステップ 4 では、ステップ 2 と 3 を 1 つの三角形だけでなく、すべての三角形に対して行う必要がある (上の例)。
このため、ポリゴンを表すすべての三角形を作成するための<u>イテレーション</u> (繰り返し) が必要である。Figure <a href="algorithms.html#fig:polycent">11.3</a> に示す。
<code><a href="https://rdrr.io/r/base/lapply.html">lapply()</a></code> と <code><a href="https://rdrr.io/r/base/lapply.html">vapply()</a></code> が各三角形の反復処理に使われているのは、Base R で簡潔な解が得られるからである。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
&lt;code&gt;vapply()&lt;/code&gt; のドキュメントについては &lt;code&gt;?lapply&lt;/code&gt; を参照。イテレーションについては Chapter &lt;a href="location.html#location"&gt;14&lt;/a&gt; を参照。&lt;/p&gt;'><sup>81</sup></a></p>
<div class="sourceCode" id="cb411"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">i</span> <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/dimensions.html">nrow</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">T_all</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">i</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="va">x</span><span class="op">:</span><span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="va">C_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">T_all</span>,  <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">C</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rbind</span>, <span class="va">C_list</span><span class="op">)</span></span>
<span></span>
<span><span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">vapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span></span>
<span>  <span class="op">}</span>, FUN.VALUE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:polycent"></span>
<img src="figures/polycent-1.png" alt="複数の三角による繰り返し重心アルゴリズム。繰り返し 2 と 3 における X は、面積加重重心。" width="100%"><p class="caption">
FIGURE 11.3: 複数の三角による繰り返し重心アルゴリズム。繰り返し 2 と 3 における X は、面積加重重心。
</p>
</div>
<p>これで、ステップ 4 を完了し、総面積を <code>sum(A)</code> で計算し、ポリゴンの重心座標を <code>weighted.mean(C [, 1] , A)</code> と <code>weighted.mean(C [, 2] , A)</code> でポリゴンの重心座標を計算する (注意深い読者のための練習: これらのコマンドが動作することを確認してみよう)。
アルゴリズムとスクリプトの関連性を示すために、このセクションの内容を凝縮して <code>11-centroid-alg.R</code> とした。
Section <a href="algorithms.html#scripts">11.2</a> の最後で、このスクリプトが正方形の重心を計算する方法を見た。
アルゴリズムを<u>スクリプト</u>化することの素晴らしい点は、新しい <code>poly_mat</code> オブジェクト上で動作することである (<code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> を参照してこれらの結果を検証するには、以下の演習を参照)。</p>
<div class="sourceCode" id="cb412"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"code/11-centroid-alg.R"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "The area is: 245"</span></span>
<span><span class="co">#&gt; [1] "The coordinates of the centroid are: 8.83, 9.22"</span></span></code></pre></div>
<p>上記の例では、低レベルの地理的な操作は、base R で第一原理から開発することが<u>できる</u>ことが示されている。
また、すでに試行錯誤したソリューションが存在する場合、車輪の再発明をする価値はないことも示している。
もし、ポリゴンの重心を求めるだけなら、<code>poly_mat</code> を <strong>sf</strong> オブジェクトとして表現し、代わりに既存の <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> 関数を使用する方が早かっただろう。
しかし、第一原理でアルゴリズムを書くことの大きな利点は、プロセスのすべての段階を理解できることであり、他の人のコードを使うときには保証されないことである。
さらに考慮すべきは性能である。R は C++ のような低レベルの言語と比較すると数値計算が遅いことが多く、最適化が困難である (Section <a href="intro.html#software-for-geocomputation">1.4</a> 参照)。
新しい手法の開発を目的とするのであれば、計算効率を優先させるべきではない。
これは、「早すぎる最適化はプログラミングにおける諸悪の根源 (あるいは少なくともそのほとんど)」という言葉に集約される <span class="citation">(<a href="references.html#ref-knuth_computer_1974">Knuth 1974</a>)</span>。</p>
<p>アルゴリズム開発は大変な作業である。
このことは、Base R を使った重心アルゴリズムの開発に費やした作業量から明らかである。このアルゴリズムは、実世界での応用が限られている問題に対する一つの、むしろ非効率的なアプローチに過ぎない。というのも、実際には凸ポリゴンは珍しいからである。
この経験は、GEOS や CGAL (計算幾何学アルゴリズムライブラリ, Computational Geometry Algorithms Library) など、高速に動作し、かつ幅広い入力ジオメトリタイプに対応する低レベル地理ライブラリの理解につながるはずである。
このようなライブラリのオープンソース化の大きな利点は、そのソースコードが、研究、理解、(技術と自信があれば) 改変のために容易に利用できることである。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
CGAL の関数 &lt;code&gt;CGAL::centroid()&lt;/code&gt; は、&lt;a href="https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html" class="uri"&gt;https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html&lt;/a&gt; で説明しているように、実際には 7 つのサブ関数で構成されており、幅広い入力データ型に対応できるようになっているが、私たちが作成したソリューションは特定の入力データ型にのみ対応する。
GEOS の関数 &lt;code&gt;Centroid::getCentroid()&lt;/code&gt; の基礎となるソースコードは、&lt;a href="https://github.com/libgeos/geos/search?q=getCentroid" class="uri"&gt;https://github.com/libgeos/geos/search?q=getCentroid&lt;/a&gt; で見ることができる。&lt;/p&gt;'><sup>82</sup></a></p>
</div>
<div id="functions" class="section level2" number="11.4">
<h2>
<span class="header-section-number">11.4</span> 関数<a class="anchor" aria-label="anchor" href="#functions"><i class="fas fa-link"></i></a>
</h2>
<p>アルゴリズムと同様に 、関数は入力を受け取り、出力を返す。
しかし、関数は、「レシピ」そのものではなく、特定のプログラミング言語での実装を指している。
R では、関数はそれ自体がオブジェクトであり、モジュール方式で作成したり結合したりすることができる。
例えば、重心生成アルゴリズムのステップ 2 を引き受ける関数を以下のように作成することができる。</p>
<div class="sourceCode" id="cb413"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_centroid</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>上記の例では、<a href="https://adv-r.hadley.nz/functions.html">関数</a>の 2 つの重要な構成要素を示している。(1) 関数の中身 (<em>body</em>) は、中括弧内のコードで、関数が入力に対して何をするかを定義する。 (2) 引数 (<em>argument</em>) は 、関数が扱う引数のリスト。この場合は <code>x</code> である (3 番目の重要なコンポーネント、環境はこのセクションの範囲外)。
デフォルトでは、関数は最後に計算したオブジェクトを返す (<code>t_centroid()</code> の場合は重心の座標)。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
また、関数の本文に &lt;code&gt;return(output)&lt;/code&gt; を追加することで、関数の出力を明示的に設定することができる。 &lt;code&gt;output&lt;/code&gt; は返すべき結果である。&lt;/p&gt;"><sup>83</sup></a></p>
<p>この関数は、前のセクションのポリゴンの例から最初の三角形の面積を計算する以下のコマンドのように、渡した入力に対して動作する (Figure <a href="algorithms.html#fig:polycent">11.3</a> を参照)。</p>
<div class="sourceCode" id="cb414"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">t_centroid</span><span class="op">(</span><span class="va">T1</span><span class="op">)</span></span>
<span><span class="co">#&gt; x_coords y_coords </span></span>
<span><span class="co">#&gt;     14.0     11.7</span></span></code></pre></div>
<p>また、三角形の面積を計算する関数を作成することができる。ここでは、<code>t_area()</code> と名付ける。</p>
<div class="sourceCode" id="cb415"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_area</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span></span>
<span>    <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>なお、この関数を作成した後は、1 行のコードで三角形の面積を計算できるようになり、冗長なコードの重複を避けることができる。
関数は、コードを一般化するためのメカニズムである。
新たに作成した関数 <code>t_area()</code> は、これまで使ってきた「三角行列」データ構造と同じ寸法を持つと仮定した任意のオブジェクト <code>x</code> を受け取り、その面積を返すもので、<code>T1</code> で図示すると次のようになる。</p>
<div class="sourceCode" id="cb416"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">t_area</span><span class="op">(</span><span class="va">T1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 85</span></span></code></pre></div>
<p>関数を使って、高さ 1、底辺 3 の新しい三角行列の面積を求めることで、その一般化可能性を検証することができる。</p>
<div class="sourceCode" id="cb417"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">t_new</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>              y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">t_area</span><span class="op">(</span><span class="va">t_new</span><span class="op">)</span></span>
<span><span class="co">#&gt;   x </span></span>
<span><span class="co">#&gt; 1.5</span></span></code></pre></div>
<p>関数の便利な点は、モジュール化されていることである。
出力が何であるかが分かっていれば、ある関数を別の関数の構成要素として利用することができる。
したがって、関数 <code>t_centroid()</code> と <code>t_area()</code> は、スクリプト <code>11-centroid-alg.R</code> というより大きな関数のサブコンポーネントとして使うことができる。このスクリプトは、任意の凸ポリゴンの面積を計算する。
以下のコードでは、凸ポリゴンに対する <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> の動作を模倣する関数 <code>poly_centroid()</code> を作成している。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
なお、作成した関数は、&lt;code&gt;lapply()&lt;/code&gt; と &lt;code&gt;vapply()&lt;/code&gt; の関数呼び出しで繰り返し呼び出されている。&lt;/p&gt;"><sup>84</sup></a></p>
<div class="sourceCode" id="cb418"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_centroid</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">Origin</span> <span class="op">=</span> <span class="va">poly_mat</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="co"># create a point representing the origin</span></span>
<span>  <span class="va">i</span> <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/dimensions.html">nrow</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="va">T_all</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">i</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="va">x</span><span class="op">:</span><span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span><span class="op">}</span><span class="op">)</span></span>
<span>  <span class="va">C_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="va">t_centroid</span><span class="op">)</span></span>
<span>  <span class="va">C</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rbind</span>, <span class="va">C_list</span><span class="op">)</span></span>
<span>  <span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">vapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="va">t_area</span>, FUN.VALUE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/weighted.mean.html">weighted.mean</a></span><span class="op">(</span><span class="va">C</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, <span class="va">A</span><span class="op">)</span>, <span class="fu"><a href="https://rspatial.github.io/terra/reference/weighted.mean.html">weighted.mean</a></span><span class="op">(</span><span class="va">C</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, <span class="va">A</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb419"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">poly_centroid</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 8.83 9.22</span></span></code></pre></div>
<p><code>poly_centroid()</code> などの関数はさらに拡張して、さまざまなタイプの出力を提供することができる。
例えば、結果をクラス <code>sfg</code> のオブジェクトとして返すには、結果を返す前に、「ラッパー」関数を用いて <code>poly_centroid()</code> の出力を変更することができる。</p>
<div class="sourceCode" id="cb420"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_centroid_sfg</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">centroid_coords</span> <span class="op">=</span> <span class="fu">poly_centroid</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="va">centroid_coords</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>以下のように、<code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> からの出力と同じであることが確認できる。</p>
<div class="sourceCode" id="cb421"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_sfc</span> <span class="op">=</span> <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/identical.html">identical</a></span><span class="op">(</span><span class="fu">poly_centroid_sfg</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span>, <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">poly_sfc</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div id="programming" class="section level2" number="11.5">
<h2>
<span class="header-section-number">11.5</span> プログラミング<a class="anchor" aria-label="anchor" href="#programming"><i class="fas fa-link"></i></a>
</h2>
<p>この章では、スクリプトからアルゴリズムという厄介なトピックを経由して関数へと移った。
抽象的な議論だけでなく、具体的な問題を解決するために、それぞれの実用例を作成した。</p>
<ul>
<li>スクリプト <code>11-centroid-alg.R</code> を導入し、「ポリゴンマトリックス」で実行した。</li>
<li>このスクリプトを動作させるための個々のステップは、アルゴリズム、つまり計算レシピとして記述した。</li>
<li>アルゴリズムを一般化するために、このアルゴリズムをモジュール関数に変換し、最終的にそれらを組み合わせて、前節の関数 <code>poly_centroid()</code> を作成した。</li>
</ul>
<p>これらのステップは、簡単なことである。
しかし、プログラミングの技術とは、スクリプト、アルゴリズム、関数を<u>組み合わせ</u>て、性能の良い<u>システム</u>にすることなのである。
できたものは、堅牢で、皆が簡単に使えるものであるべきである。
この本を読んでいるほとんどの人がそうであるように、プログラミングの初心者であれば、前のセクションの結果を追って再現できることは、大きな達成感を得ることができるはずである。
プログラミングができるようになるまでには、何時間もかけて熱心に勉強し、練習する必要がある。</p>
<p>新しいアルゴリズムを効率的に実装する際の課題は、実運用で使用することを意図していない単純な関数を作成するために費やした作業量を考慮すると、はるかに遠い。現在の状態では、<code>poly_centroid()</code> はほとんどの (非凸) ポリゴンで失敗する!
ここから生じる疑問は、関数をどのように一般化するかということである。
(1) 非凸ポリゴンを三角測量する方法を探す (geocompx.github.io/geocompkg/articles/ のオンライン記事 <a href="https://geocompx.github.io/geocompkg/articles/algorithm.html">Algorithms Extended</a> で扱っている話題) と (2) 三角メッシュに依存しない他の重心のアルゴリズムを調べるという 2 つの選択肢がある。</p>
<p>もっと大きな疑問は、高性能なアルゴリズムがすでに実装され、<code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> のような関数にパッケージされているのに、ソリューションをプログラミングする価値があるのだろうか、ということである。
この具体的なケースにおける還元論的な答えは「価値はない」である。
広い意味で、プログラミングを学ぶことの利点を考えると、答えは「場合による」である。
プログラミングでは、あるメソッドを実装しようとすると、すでに誰かがその苦労をしていることに気づき、何時間も無駄にすることがよくある。
本章は、ジオアルゴリズムのプログラミングへの第一歩として捉えることができる。
しかし、一般化された解決策をプログラムする場合と、既存の高水準の解決策を利用する場合の教訓とも言える。
新しい関数を作るのが最善の場合もあれば、すでにある関数を使うのが良い場合もある。</p>
<p>「車輪の再発明をするな」という言葉は、他の人生の歩みと同様、いやそれ以上にプログラミングに当てはまる。
プロジェクトの最初に少し調査して考えることで、プログラミングの時間をどこに費やすのがベストなのかを決めることができる。
また、以下の 3 つの原則は、簡単なスクリプトであれ、何百もの関数で構成されるパッケージであれ、コードを書くときに労力を最大限に活用するのに役立つ。</p>
<ol style="list-style-type: decimal">
<li>
<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> (don’t repeat yourself): コードの繰り返しを最小限に抑え、より少ないコード行数で特定の問題を解決することを目指す。
この原則は、「R for Data Science」の「Functions」の章において、コードの繰り返しを減らすための関数の使用を参照して説明されている <span class="citation">(<a href="references.html#ref-grolemund_r_2016">Grolemund and Wickham 2016</a>)</span>。</li>
<li>
<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a> (keep it simple stupid): この原則は、複雑な解決策よりも単純な解決策を最初に試し、必要に応じて依存関係を使用し、スクリプトを簡潔に保つことを目指すことを示唆。
この原則は、「ものごとはできるかぎりシンプルにすべきだ。しかし、シンプルすぎてもいけない。 」“things should be made as simple as possible, but no simpler” という<a href="https://www.nature.com/articles/d41586-018-05004-4">名言</a> のコンピュータ版である。</li>
<li>Modularity: コードを明確に分割することで、メンテナンスが容易になる。
関数は、たった一つのことをするだけにして、それに専念するべきである。
もし関数が長くなりすぎたら、それを複数の小さな関数に分割し、それぞれを別の目的に再利用することを考えよう。</li>
</ol>
<p>この章だけで、すぐに完璧な関数を作成できるようになることは保証していない。
しかし、この章の内容は、いつ挑戦するのが適切かを判断するのに役立つと確信している (問題を解決する既存の関数がない場合、プログラミングタスクが自分の能力の範囲内にある場合、そのソリューションの利点が開発にかかる時間コストを上回ると思われる場合)。
上記の原則と、上記の例を通しての実践的な経験を組み合わせることで、スクリプト、パッケージ作成、プログラミングのスキルを手に入れることができる。
プログラミングへの最初の一歩は時間がかかるが (以下の演習は急がないように)、長期的な見返りは大きくなるだろう。</p>
</div>
<div id="ex-algorithms" class="section level2" number="11.6">
<h2>
<span class="header-section-number">11.6</span> 演習<a class="anchor" aria-label="anchor" href="#ex-algorithms"><i class="fas fa-link"></i></a>
</h2>
<p>E1. 本書の GitHub リポジトリの <a href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a> スクリプトを読みなさい。</p>
<ul>
<li>ベストプラクティスのうちどれを使っているか？</li>
<li>RStudio などの IDE を使い、自分のパソコンでスクリプトを作成しなさい (スクリプトを 1 行ずつ打ち込み、適宜コメントを入れると良い。コピペはしない。この作業でスクリプトの入力の仕方を学ぶことができる。)。正方形ポリゴン (<code>poly_mat = cbind(x = c(0, 9, 9, 0, 0), y = c(0, 0, 9, 9, 0))</code> で作成) の例を使い、スクリプトを 1 行ずつ実行しなさい。</li>
<li>再現可能性を高めるためにはどのように変更したら良いか?</li>
<li>ドキュメンテーションをより良くするためにはどうしたら良いか?</li>
</ul>
<p>E2. 幾何アルゴリズムのセクションで、<code>poly_mat</code> のポリゴンの面積は 245 で、重心は座標 (8.8, 9.2) であると計算した。</p>
<ul>
<li>このアルゴリズムのスクリプトである <a href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a> を参照し、自分のパソコンで結果を再現しなさい (ボーナス: コピペせずに自分で入力しなさい)。</li>
<li>結果は正しいか? <code>poly_mat</code> を <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon()</a></code> 関数で <code>sfc</code> オブジェクトに変換し (<code>poly_sfc</code> という名前)、<code><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_area()</a></code> 関数と <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> 関数を用いて検証しなさい (ヒント: この関数は、クラス <code><a href="https://rdrr.io/r/base/list.html">list()</a></code> を引数に取る)。</li>
</ul>
<p>E3. 我々が作成したアルゴリズムは<strong>凸包</strong>に対してのみ動作すると記載されている。凸包を定義し (ジオメトリ操作の章を参照)、凸包でないポリゴンでアルゴリズムをテストしなさい。</p>
<ul>
<li>ボーナス 1: なぜこの方法が凸の外皮に対してのみ機能するのかを考え、他の種類の多角形に対して機能させるためにアルゴリズムに加える必要がある変更点に注意する。</li>
<li>ボーナス 2: <code>11-centroid-alg.R</code> の内容を基に、行列形式で表現された線分の全長を求めることができる、Base R 関数のみを使ったアルゴリズムを書きなさい。</li>
</ul>
<!-- Todo: add example of matrix representing a linestring, demonstrate code to verify the answer, suggest alternative functions to decompose as a bonus. --><p>E4. 関数のセクションでは、<code>sfg</code> クラスの出力 (<code>poly_centroid_sfg()</code>) と <code>matrix</code> 型の出力 (<code>poly_centroid_type_stable()</code>) を生成する <code>poly_centroid()</code> 関数の異なるバージョンを作成した。
さらに、型が安定で (<code>sf</code> クラスの入力しか受け付けない) <code>sf</code> オブジェクトを返すバージョン (例えば <code>poly_centroid_sf()</code>) を作成し、関数を拡張しなさい (ヒント: <code>sf::st_coordinates(x)</code> コマンドでオブジェクト <code>x</code> を行列に変換する必要があるかもしれない)。</p>
<ul>
<li>
<code>poly_centroid_sf(sf::st_sf(sf::st_sfc(poly_sfc)))</code> を実行し、動作するか検証しなさい</li>
<li>
<code>poly_centroid_sf(poly_mat)</code> を実行しようとした時、どのようなエラーメッセージが表示されたか?</li>
</ul>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="gis.html"><span class="header-section-number">10</span> GIS ソフトウェアへのブリッジ</a></div>
<div class="next"><a href="spatial-cv.html"><span class="header-section-number">12</span> 統計的学習</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Second Edition</h2>
    <!--<p>Now is a great time to provide feedback</p>-->
        <ul class="list-unstyled">
<!--<li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Provide feedback (5 min)</a></li>--><li><a href="https://geocompx.org/">Visit the geocompx website 🌐</a></li>
          <li><a href="https://r.geocompx.org/#reproducibility">Install updated packages 💾</a></li>
          <li><a href="https://github.com/geocompx/geocompr/issues">Open an issue <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Chat on Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://r.geocompx.org/solutions/">Check exercise solutions <i class="fa fa-check"></i></a></li>
          <li><a href="https://supportukrainenow.org/">Support Ukraine 🇺🇦
</a></li>
          <li><a href="https://donate.stripe.com/4gweWl94Q9E35AQ6oo">Support this project 💸</a></li>
        </ul>
<div class="LECTURE_IN_JAPANESE" style="border:solid 1px;border-color:#be1558;background:#fbcbc9"><a href="https://peatix.com/group/16401222" target="_blank">2025年4月頃より、レクチャーを計画しています。Peatix でフォローしてください。</a></div>
        <hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#algorithms"><span class="header-section-number">11</span> スクリプト、アルゴリズム、関数</a></li>
<li><a class="nav-link" href="#prerequisites-11">必須パッケージ</a></li>
<li><a class="nav-link" href="#intro-algorithms"><span class="header-section-number">11.1</span> イントロダクション</a></li>
<li><a class="nav-link" href="#scripts"><span class="header-section-number">11.2</span> スクリプト</a></li>
<li><a class="nav-link" href="#geometric-algorithms"><span class="header-section-number">11.3</span> 幾何学的アルゴリズム</a></li>
<li><a class="nav-link" href="#functions"><span class="header-section-number">11.4</span> 関数</a></li>
<li><a class="nav-link" href="#programming"><span class="header-section-number">11.5</span> プログラミング</a></li>
<li><a class="nav-link" href="#ex-algorithms"><span class="header-section-number">11.6</span> 演習</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompx/geocompr/blob/main/11-algorithms-ja.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompx/geocompr/edit/main/11-algorithms-ja.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation with R</strong>" was written by Robin Lovelace, Jakub Nowosad, Jannes Muenchow. It was last built on 2025-06-11.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
