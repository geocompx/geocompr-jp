<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 12 統計的学習 | Geocomputation with R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="必須パッケージ 本章では、Chapter 2 から Chapter 7 までの内容を学習し、演習を行うなどして、地理データ解析 に習熟していることを前提としている。 一般化線形モデル (Generalized Linear Model, GLM) と機械学習に精通していることを強く推奨する James et al. (2013)。 この章では、以下のパッケージを使用する。85...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 12 統計的学習 | Geocomputation with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://r.geocompx.org/jp/spatial-cv.html">
<meta property="og:image" content="https://r.geocompx.org/jp/images/cover2.png">
<meta property="og:description" content="必須パッケージ 本章では、Chapter 2 から Chapter 7 までの内容を学習し、演習を行うなどして、地理データ解析 に習熟していることを前提としている。 一般化線形モデル (Generalized Linear Model, GLM) と機械学習に精通していることを強く推奨する James et al. (2013)。 この章では、以下のパッケージを使用する。85...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 12 統計的学習 | Geocomputation with R">
<meta name="twitter:description" content="必須パッケージ 本章では、Chapter 2 から Chapter 7 までの内容を学習し、演習を行うなどして、地理データ解析 に習熟していることを前提としている。 一般化線形モデル (Generalized Linear Model, GLM) と機械学習に精通していることを強く推奨する James et al. (2013)。 この章では、以下のパッケージを使用する。85...">
<meta name="twitter:image" content="https://r.geocompx.org/jp/images/cover2.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.10/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.10/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.10/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><meta name="citation_title" content="Chapter 12 統計的学習 | Geocomputation with R">
<meta name="citation_author" content="Robin Lovelace">
<meta name="citation_author" content="Jakub Nowosad">
<meta name="citation_author" content="Jannes Muenchow">
<meta name="citation_publication_date" content="2019">
<meta name="citation_isbn" content="9780203730058">
<link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">
<script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.2.2/leaflet.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDC2S0ZNH5"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VDC2S0ZNH5');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ようこそ</a></li>
<li><a class="" href="foreword-1st-edition.html">序文 (第 1 版)</a></li>
<li><a class="" href="forward-2nd-edition.html">序文 (第 2 版)</a></li>
<li><a class="" href="preface.html">序文</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> はじめに</a></li>
<li class="book-part">基本機能</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> 地理データと R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> 属性データ操作</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> 空間データ操作</a></li>
<li><a class="" href="geometry-operations.html"><span class="header-section-number">5</span> ジオメトリ演算</a></li>
<li><a class="" href="raster-vector.html"><span class="header-section-number">6</span> ラスタとベクタの相互作用</a></li>
<li><a class="" href="reproj-geo-data.html"><span class="header-section-number">7</span> 地理データの再投影</a></li>
<li><a class="" href="read-write.html"><span class="header-section-number">8</span> 地理データI/O</a></li>
<li class="book-part">拡張機能</li>
<li><a class="" href="adv-map.html"><span class="header-section-number">9</span> R で地図を作成</a></li>
<li><a class="" href="gis.html"><span class="header-section-number">10</span> GIS ソフトウェアへのブリッジ</a></li>
<li><a class="" href="algorithms.html"><span class="header-section-number">11</span> スクリプト、アルゴリズム、関数</a></li>
<li><a class="active" href="spatial-cv.html"><span class="header-section-number">12</span> 統計的学習</a></li>
<li class="book-part">応用</li>
<li><a class="" href="transport.html"><span class="header-section-number">13</span> 交通解析</a></li>
<li><a class="" href="location.html"><span class="header-section-number">14</span> 商圏分析</a></li>
<li><a class="" href="eco.html"><span class="header-section-number">15</span> 生態学</a></li>
<li><a class="" href="conclusion.html"><span class="header-section-number">16</span> 結論</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompx/geocompr">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="spatial-cv" class="section level1" number="12">
<h1>
<span class="header-section-number">12</span> 統計的学習<a class="anchor" aria-label="anchor" href="#spatial-cv"><i class="fas fa-link"></i></a>
</h1>
<div id="prerequisites-12" class="section level2 unnumbered">
<h2>必須パッケージ<a class="anchor" aria-label="anchor" href="#prerequisites-12"><i class="fas fa-link"></i></a>
</h2>
<p>本章では、Chapter <a href="spatial-class.html#spatial-class">2</a> から Chapter <a href="reproj-geo-data.html#reproj-geo-data">7</a> までの内容を学習し、演習を行うなどして、地理データ解析 に習熟していることを前提としている。
一般化線形モデル (Generalized Linear Model, GLM) と機械学習に精通していることを強く推奨する <span class="citation">James et al. (<a href="references.html#ref-james_introduction_2013">2013</a>)</span>。</p>
<p>この章では、以下のパッケージを使用する。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
パッケージ &lt;strong&gt;GGally&lt;/strong&gt;、&lt;strong&gt;lgr&lt;/strong&gt;、&lt;strong&gt;kernlab&lt;/strong&gt;、&lt;strong&gt;mlr3measures&lt;/strong&gt;、&lt;strong&gt;paradox&lt;/strong&gt;、&lt;strong&gt;pROC&lt;/strong&gt;、&lt;strong&gt;progressr&lt;/strong&gt;、&lt;strong&gt;spDataLarge&lt;/strong&gt; もインストールする必要があるが、ロードしておく必要はない。&lt;/p&gt;"><sup>85</sup></a></p>
<div class="sourceCode" id="cb422"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/">terra</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org">dplyr</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://future.futureverse.org">future</a></span><span class="op">)</span>             <span class="co"># 並列処理</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://s-fleck.github.io/lgr/">lgr</a></span><span class="op">)</span>                <span class="co"># logging framework for R</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3.mlr-org.com">mlr3</a></span><span class="op">)</span>               <span class="co"># 機械学習アルゴリズムへの統一インターフェース</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3learners.mlr-org.com">mlr3learners</a></span><span class="op">)</span>       <span class="co"># 最重要の機械学習アルゴリズム</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">mlr3extralearners</span><span class="op">)</span>  <span class="co"># その他の機械学習アルゴリズム</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3spatiotempcv.mlr-org.com/">mlr3spatiotempcv</a></span><span class="op">)</span>   <span class="co"># 時空間リサンプリング</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3proba.mlr-org.com">mlr3proba</a></span><span class="op">)</span>          <span class="co"># mlr3extralearners::list_learners() が使う</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3tuning.mlr-org.com">mlr3tuning</a></span><span class="op">)</span>         <span class="co"># ハイパーパラメータのチューニング</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3viz.mlr-org.com">mlr3viz</a></span><span class="op">)</span>            <span class="co"># mlr3 オブジェクトのプロット関数</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://progressr.futureverse.org">progressr</a></span><span class="op">)</span>          <span class="co"># 進捗状況を報告</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://xrobin.github.io/pROC/">pROC</a></span><span class="op">)</span>               <span class="co"># ROC 値を計算</span></span></code></pre></div>
<p>データは必要に応じて読み込む。</p>
</div>
<div id="intro-cv1" class="section level2" number="12.1">
<h2>
<span class="header-section-number">12.1</span> イントロダクション<a class="anchor" aria-label="anchor" href="#intro-cv1"><i class="fas fa-link"></i></a>
</h2>
<p>統計的学習は、データのパターンを特定し、そのパターンから予測するための統計的・計算的モデルの使用に関するものである。
その起源から、統計的学習は R の の大きな強みの一つである ( Section <a href="intro.html#software-for-geocomputation">1.4</a> 参照)。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
地理データに統計的手法を適用することは、地理統計学、空間統計学、点パターン解析の分野において、何十年にもわたって活発な研究テーマとなっている &lt;span class="citation"&gt;(&lt;a href="references.html#ref-diggle_modelbased_2007"&gt;Diggle and Ribeiro 2007&lt;/a&gt;; &lt;a href="references.html#ref-gelfand_handbook_2010"&gt;Gelfand et al. 2010&lt;/a&gt;; &lt;a href="references.html#ref-baddeley_spatial_2015"&gt;Baddeley, Rubak, and Turner 2015&lt;/a&gt;)&lt;/span&gt;。&lt;/p&gt;'><sup>86</sup></a>
統計的学習とは、統計学と機械学習の手法を組み合わせたもので、教師あり手法と教師なし手法に分類される。
どちらも物理学、生物学、生態学から地理学、経済学に至るまで、ますます多くの分野で利用されるようになっている <span class="citation">(<a href="references.html#ref-james_introduction_2013">James et al. 2013</a>)</span>。</p>
<p>この章では、クラスタリングのような教師なし技術ではなく、学習データセットが存在する教師あり技術に焦点を当てていきたい。
応答変数は、二値 (地すべりの発生など)、カテゴリ (土地利用)、整数 (種の豊富さ)、数値 (土壌酸性度の pH 測定値) のいずれでもよい。
教師あり技術は、観測のサンプルについて既知の応答と、1 つまたは複数の予測変数の間の関係をモデル化する。</p>
<p>多くの機械学習において、研究の主な目的は優れた予測を行うことである。
機械学習が「ビッグデータ」の時代に繁栄しているのは、その手法が入力変数に関する仮定をほとんど必要とせず、巨大なデータセットを扱えるからである。
機械学習は、将来の顧客行動予測、推奨サービス (音楽、映画、次に買うもの)、顔認識、自律走行、テキスト分類、予知保全 (インフラ、産業) などのタスクに資するものである。</p>
<p>この章では、地すべりの発生モデルという事例をもとに説明する。
この応用例は、Chapter <a href="intro.html#intro">1</a> で定義されているジオコンピュテーションの応用的な性質とリンクしており、機械学習が、予測を唯一の目的とする場合に統計学の分野から借用する方法を示している。
そこで、この章では、まず、GLM <span class="citation">(<a href="references.html#ref-zuur_mixed_2009">A. Zuur et al. 2009</a>)</span> の助けを借りて、モデリングと交差検証 (cross validation, CV) の概念を紹介する。
これを踏まえて、この章では、より典型的な機械学習 アルゴリズム 、すなわちサポートベクタマシン (Support Vector Machine, SVM) を実装している。
モデルの<strong>予測性能</strong>は、地理データが特殊であることを考慮した空間交差検証 (空間 CV) を用いて評価していこう。</p>
<p>CV データセットをトレーニングセットとテストセットに (繰り返し) 分割することで、モデルが新しいデータに対して汎化する能力を決定する。
学習データを使ってモデルを適合させ、テストデータに対して予測したときの性能をチェックする。
CV は過適合を検出するのに役立つ。なぜなら、学習データをあまりに忠実に予測するモデル (ノイズ) は、テストデータでのパフォーマンスが低くなる傾向があるからである。</p>
<p>空間データをランダムに分割することで、テスト点と空間的に隣接する学習点を得ることができる。
空間的に自己相関していると、このシナリオではテストとトレーニングのデータセットが独立しておらず、結果として CV は過適合の可能性を検出できなくなる。
空間交差検証 は、本章の<strong>中心</strong>テーマであり、この問題を軽減する。。</p>
<p>繰り返しになるが、この章ではモデルの<strong>予測性能</strong>に焦点を当てる。
予測地図は<strong>扱わない</strong>。
これは、Chapter <a href="eco.html#eco">15</a> で扱う。</p>
</div>
<div id="case-landslide" class="section level2" number="12.2">
<h2>
<span class="header-section-number">12.2</span> ケーススタディ: 地すべりの発生しやすさ<a class="anchor" aria-label="anchor" href="#case-landslide"><i class="fas fa-link"></i></a>
</h2>
<p>このケーススタディは、Ecuador 南部の地すべり地点のデータセットに基づいている。図は Figure <a href="spatial-cv.html#fig:lsl-map">12.1</a>、詳細は <span class="citation">Muenchow, Brenning, and Richter (<a href="references.html#ref-muenchow_geomorphic_2012">2012</a>)</span> で説明されている。
論文で使用されたデータセットの部分集合は <strong>spDataLarge</strong> パッケージで提供されており、以下のように読み込むことができる。</p>
<div class="sourceCode" id="cb423"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"lsl"</span>, <span class="st">"study_mask"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">ta</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/ta.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>上記のコードでは、<code>lsl</code>、<code>sf</code> という名前の <code>data.frame</code>、<code>study_mask</code> という名前の <code>sf</code> オブジェクト、そして <code>ta</code> (Section <a href="spatial-class.html#raster-classes">2.3.4</a> を参照) という名前の地形属性ラスタ <code>SpatRaster</code> という 3 つのオブジェクトをロードしている。
<code>lsl</code> は要因列 <code>lslpts</code> を含み、<code>TRUE</code>は観測された地すべり「開始点」に対応し、座標は列 <code>x</code> と <code>y</code> に格納されている。 <a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
地すべり開始点は、地すべりポリゴンの崖に位置する。詳細は &lt;span class="citation"&gt;Muenchow, Brenning, and Richter (&lt;a href="references.html#ref-muenchow_geomorphic_2012"&gt;2012&lt;/a&gt;)&lt;/span&gt; を参照。&lt;/p&gt;'><sup>87</sup></a>
<code>summary(lsl$lslpts)</code> に示すように、地すべり地点が 175 箇所、非地すべり地点が 175 箇所ある。
非地すべり点 175 点は、地すべりポリゴン周辺の小さな緩衝地帯の外に位置しなければならないという制約のもと、調査地域からランダムにサンプル化されたものである。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:lsl-map"></span>
<img src="images/lsl-map-1.png" alt="Ecuador 南部における地すべり発生地点 (赤) と地すべりの影響を受けていない地点 (青)。" width="70%"><p class="caption">
FIGURE 12.1: Ecuador 南部における地すべり発生地点 (赤) と地すべりの影響を受けていない地点 (青)。
</p>
</div>
<p></p>
<p>Table <a href="spatial-cv.html#tab:lslsummary">12.1</a> に、<code>lsl</code> の最初の 3 行を有効数字 2 桁に丸めたものを掲載している。</p>
<div class="inline-table"><table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:lslsummary">TABLE 12.1: </span><span id="tab:lslsummary">TABLE 12.2: </span>lsl データセットの構成。
</caption>
<thead><tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
x
</th>
<th style="text-align:right;">
y
</th>
<th style="text-align:left;">
lslpts
</th>
<th style="text-align:right;">
slope
</th>
<th style="text-align:right;">
cplan
</th>
<th style="text-align:right;">
cprof
</th>
<th style="text-align:right;">
elev
</th>
<th style="text-align:right;">
log10_carea
</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
713888
</td>
<td style="text-align:right;">
9558537
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
34
</td>
<td style="text-align:right;">
0.023
</td>
<td style="text-align:right;">
0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
2.8
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
712788
</td>
<td style="text-align:right;">
9558917
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
39
</td>
<td style="text-align:right;">
-0.039
</td>
<td style="text-align:right;">
-0.017
</td>
<td style="text-align:right;">
2100
</td>
<td style="text-align:right;">
4.1
</td>
</tr>
<tr>
<td style="text-align:left;">
350
</td>
<td style="text-align:right;">
713826
</td>
<td style="text-align:right;">
9559078
</td>
<td style="text-align:left;">
TRUE
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
0.020
</td>
<td style="text-align:right;">
-0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
3.2
</td>
</tr>
</tbody>
</table></div>
<p>地すべりの発生しやすさをモデル化するためには、いくつかの予測因子が必要である。
地形属性は地すべりと関連することが多いので <span class="citation">(<a href="references.html#ref-muenchow_geomorphic_2012">Muenchow, Brenning, and Richter 2012</a>)</span>、すでに <code>ta</code> から <code>lsl</code> まで、以下の地形属性を抽出している。</p>
<ul>
<li>
<code>slope</code> : 傾斜角 (°)</li>
<li>
<code>cplan</code> : 斜面の収束・発散を表す平面曲率 (rad m<sup>-1</sup>) で、水の流れを表現する。</li>
<li>
<code>cprof</code> : 流れの加速度の指標としてのプロファイル曲率 (rad m<sup>-1</sup>)、傾斜角のダウンスロープ変化としても知られている。</li>
<li>
<code>elev</code> : 調査地域の植生と降水量の異なる標高帯を表す標高 (m a.s.l.)</li>
<li>
<code>log10_carea</code> : ある地点に向かって流れる水の量を表す集水面積の十進対数 (log10 m<sup>2</sup>) のこと。</li>
</ul>
<p>R-GIS ブリッジ (Chapter <a href="gis.html#gis">10</a> 参照) を用いて地形属性を計算し、地すべり地点に抽出することは、有意義な演習となるだろう (本章末の演習の項参照)。</p>
</div>
<div id="conventional-model" class="section level2" number="12.3">
<h2>
<span class="header-section-number">12.3</span> R による従来のモデリング手法<a class="anchor" aria-label="anchor" href="#conventional-model"><i class="fas fa-link"></i></a>
</h2>
<p>何十もの学習アルゴリズムへの統一的なインタフェースを提供するアンブレラパッケージである <strong>mlr3</strong> パッケージを紹介する (Section <a href="spatial-cv.html#spatial-cv-with-mlr3">12.5</a>) が、その前に R の従来のモデリングインタフェースについて見ておく価値がある。
この教師あり統計学習の入門は、空間交差検証 を行うための基礎となり、この後に紹介する <strong>mlr3</strong> のアプローチの把握に貢献する。</p>
<p>教師あり学習では、予測変数の関数として応答変数を予測する (Section <a href="spatial-cv.html#intro-cv">12.4</a>)。
R では、モデリング関数は通常、数式を使って指定する (R の数式の詳細については、<code><a href="https://rdrr.io/r/stats/formula.html">?formula</a></code> を参照)。
次のコマンドは、一般化線形モデルを指定し、実行する。</p>
<div class="sourceCode" id="cb424"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">lslpts</span> <span class="op">~</span> <span class="va">slope</span> <span class="op">+</span> <span class="va">cplan</span> <span class="op">+</span> <span class="va">cprof</span> <span class="op">+</span> <span class="va">elev</span> <span class="op">+</span> <span class="va">log10_carea</span>,</span>
<span>          family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html">binomial</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>          data <span class="op">=</span> <span class="va">lsl</span><span class="op">)</span></span></code></pre></div>
<p>3 つの入力引数のそれぞれを理解しておくとよいだろう。</p>
<ul>
<li>地すべりの発生状況 (<code>lslpts</code>) を予測変数の関数として指定した式</li>
<li>モデルの種類を指定する family で、この場合は応答が二値なので <code>binomial</code> としている (<code><a href="https://rdrr.io/r/stats/family.html">?family</a></code> を参照)</li>
<li>応答と予測変数 (列として) を含むデータフレーム</li>
</ul>
<p>このモデルの結果を表示すると次のようになる (<code>summary(fit)</code> にはより詳細な説明がある)。</p>
<div class="sourceCode" id="cb425"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "glm" "lm"</span></span>
<span><span class="va">fit</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:  glm(formula = lslpts ~ slope + cplan + cprof + elev + log10_carea, </span></span>
<span><span class="co">#&gt;     family = binomial(), data = lsl)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt; (Intercept)        slope        cplan        cprof         elev  log10_carea  </span></span>
<span><span class="co">#&gt;    2.51e+00     7.90e-02    -2.89e+01    -1.76e+01     1.79e-04    -2.27e+00  </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Degrees of Freedom: 349 Total (i.e. Null);  344 Residual</span></span>
<span><span class="co">#&gt; Null Deviance:       485 </span></span>
<span><span class="co">#&gt; Residual Deviance: 373   AIC: 385</span></span></code></pre></div>
<p>クラス <code>glm</code> のモデルオブジェクト <code>fit</code> は、応答と予測変数の間の適合関係を定義する係数を含む。
また、予測にも利用することができる。
これは一般的な <code><a href="https://rspatial.github.io/terra/reference/predict.html">predict()</a></code> メソッドで行われ、この場合、関数 <code><a href="https://rdrr.io/r/stats/predict.glm.html">predict.glm()</a></code> を呼び出す。
<code>type</code> を <code>response</code> に設定すると、下図のように <code>lsl</code> の各観測値に対する (地すべり発生の) 予測確率が返される (<code><a href="https://rdrr.io/r/stats/predict.glm.html">?predict.glm</a></code> を参照)。</p>
<div class="sourceCode" id="cb426"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_glm</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/predict.html">predict</a></span><span class="op">(</span>object <span class="op">=</span> <span class="va">fit</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/headtail.html">head</a></span><span class="op">(</span><span class="va">pred_glm</span><span class="op">)</span></span>
<span><span class="co">#&gt;      1      2      3      4      5      6 </span></span>
<span><span class="co">#&gt; 0.1901 0.1172 0.0952 0.2503 0.3382 0.1575</span></span></code></pre></div>
<p>予測ラスタに係数を適用することで、空間分布図を作成することができる。
これは、手動または <code><a href="https://rspatial.github.io/terra/reference/predict.html">terra::predict()</a></code> で行うことができる。
モデルオブジェクト (<code>fit</code>) に加えて、後者の関数は、モデルの入力データフレーム (Figure <a href="spatial-cv.html#fig:lsl-susc">12.2</a>) と同じ名前の予測子 (ラスタレイヤ) を持つ <code>SpatRaster</code> も必要とする。</p>
<div class="sourceCode" id="cb427"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 予測する</span></span>
<span><span class="va">pred</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/predict.html">predict</a></span><span class="op">(</span><span class="va">ta</span>, model <span class="op">=</span> <span class="va">fit</span>, type <span class="op">=</span> <span class="st">"response"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:lsl-susc"></span>
<img src="images/lsl-susc-1.png" alt="GLM を用いた地すべり感受性の空間分布図." width="70%"><p class="caption">
FIGURE 12.2: GLM を用いた地すべり感受性の空間分布図.
</p>
</div>
<p>ここで、予測を行う際には、空間自己相関構造があってもなくても平均的に予測精度は変わらないと仮定しているため、空間自己相関を無視する。
空間自己相関 を、モデルと予測に組み入れることも可能である。
これは本書の範疇を越えるが、いくつかの資料を紹介する。</p>
<ol style="list-style-type: decimal">
<li>回帰クリギングの予測値は、回帰の予測値と回帰の残差のクリギングを組み合わせたものである <span class="citation">(<a href="references.html#ref-goovaerts_geostatistics_1997">Goovaerts 1997</a>; <a href="references.html#ref-hengl_practical_2007">Hengl 2007</a>; <a href="references.html#ref-bivand_applied_2013">Bivand, Pebesma, and Gómez-Rubio 2013</a>)</span>。</li>
<li>また、一般化最小二乗モデルに空間相関 (依存関係) 構造を追加することもできる <span class="citation">(<code><a href="https://rdrr.io/pkg/nlme/man/gls.html">nlme::gls()</a></code>, <a href="references.html#ref-zuur_mixed_2009">A. Zuur et al. 2009</a>; <a href="references.html#ref-zuur_beginners_2017">A. F. Zuur et al. 2017</a>)</span>。</li>
<li>また、混合効果モデリング・アプローチを使用することもできる。
基本的に、ランダム効果は、応答変数に従属構造を課し、それによって、あるクラスの観測が、他のクラスの観測よりも互いに類似していることを可能にする <span class="citation">(<a href="references.html#ref-zuur_mixed_2009">A. Zuur et al. 2009</a>)</span>。
クラスは、例えば、ハチの巣、フクロウの巣、植生トランセクト、標高の層別などである。
この混合モデリングのアプローチは、正規かつ独立に分布するランダム切片を仮定している。
これは、正規分布で空間的に依存するランダム切片を使用することによっても拡張することができる。
しかし、このためには、ベイズ・モデリング・アプローチに頼らなければならないだろう <span class="citation">(<a href="references.html#ref-blangiardo_spatial_2015">Blangiardo and Cameletti 2015</a>; <a href="references.html#ref-zuur_beginners_2017">A. F. Zuur et al. 2017</a>)</span>。</li>
</ol>
<p>空間分布図は、モデルの非常に重要なアウトカムの一つである。
さらに重要なのは、モデルの予測性能が低ければ、予測マップは役に立たないので、基盤となるモデルがどれだけ優れているかということである。
二項モデルの予測性能を評価する最も一般的な尺度の一つは、Area Under the Receiver Operator Characteristic Curve (AUROC) である。
これは 0.5 から 1.0 の間の値で、0.5 はランダム化より良くないモデル、1.0 は 2 つのクラスを完全に予測することを示す。
したがって、AUROC が高いほど、モデルの予測力が優れていることになる。
次のコードチャンクは、応答と予測値を入力とする <code><a href="https://rdrr.io/pkg/pROC/man/roc.html">roc()</a></code> を用いて、モデルの AUROC 値を計算するものである。
<code><a href="https://rdrr.io/pkg/pROC/man/auc.html">auc()</a></code> は、曲線の下の面積を返す。</p>
<div class="sourceCode" id="cb428"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">pROC</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pROC/man/auc.html">auc</a></span><span class="op">(</span><span class="fu">pROC</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pROC/man/roc.html">roc</a></span><span class="op">(</span><span class="va">lsl</span><span class="op">$</span><span class="va">lslpts</span>, <span class="fu"><a href="https://rdrr.io/r/stats/fitted.values.html">fitted</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Area under the curve: 0.8216</span></span></code></pre></div>
<p>AUROC の値 0.82 は良好な適合性を示している。
しかし、これは完全なデータセットに対して計算したものであるため、楽観的すぎる推定値である。
偏りを抑えた評価を導き出すためには、交差検証を用いる必要があり、空間データの場合は空間交差検証 を利用する必要がある。</p>
</div>
<div id="intro-cv" class="section level2" number="12.4">
<h2>
<span class="header-section-number">12.4</span> (空間) 交差検証の紹介<a class="anchor" aria-label="anchor" href="#intro-cv"><i class="fas fa-link"></i></a>
</h2>
<p>交差検証 は、リサンプリング法のファミリーに属する <span class="citation">(<a href="references.html#ref-james_introduction_2013">James et al. 2013</a>)</span>。
基本的な考え方としては、データセットをトレーニングセットとテストセットに (繰り返し) 分割し、トレーニングデータを使ってモデルを適合させ、それをテストセットに適用する。
予測値とテストセットの既知の応答値を比較することにより (二項式の場合は AUROC のような性能指標を使用)、学習した関係を独立したデータに一般化するモデルの能力について、バイアスを低減した評価を得ることができる。
例えば、5 倍交差検証を 100 回繰り返すとは、データをランダムに 5 分割 (フォールド) し、各フォールドをテストセットとして 1 回使用することを意味する (Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> の上段を参照)。
これは、各観測が 1 つのテストセットで 1 回使用されることを保証し、5 つのモデルの適合を必要とする。
その後、この手順を 100 回繰り返す。
もちろん、データの分割は繰り返しごとに異なる。
全体として、これは 500 のモデルに合計される。一方、すべてのモデルの平均性能指標 (AUROC) は、モデルの全体的な予測力である。</p>
<p>しかし、地理的なデータは特殊である。
Chapter <a href="transport.html#transport">13</a> で見るように、地理学の「第一法則」は、互いに近い地点は、一般に、遠い地点よりも似ているとするものである <span class="citation">(<a href="references.html#ref-miller_tobler_2004">Miller 2004</a>)</span>。
つまり、従来の CV では学習点とテスト点が近すぎることが多いため、点が統計的に独立していないことになる (Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> の最初の行を参照)。
「テスト」観測の近くにある「トレーニング」観測は、一種の「カンニング」を提供することができる。
すなわち、学習データセットでは利用できないはずの情報である。
この問題を軽減するために、観測を空間的に不連続なサブセットに分割する「空間分割」が使用される (<em>k</em>-means クラスタリングで観測の座標を使用; <span class="citation">Brenning (<a href="references.html#ref-brenning_spatial_2012">2012b</a>)</span>; Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> の 2 行目)。
この分割戦略が、従来の CV との<strong>唯一</strong>の違いである。
その結果、空間 CV はモデルの予測性能のバイアスを低減させ、過適合を回避するのに役立つ。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:partitioning"></span>
<img src="images/12_partitioning.png" alt="1 回の繰り返しの交差検証で選択されたテストおよびトレーニングの観測の空間的な可視化。ランダム (上段) および空間分割 (下段)。" width="100%"><p class="caption">
FIGURE 12.3: 1 回の繰り返しの交差検証で選択されたテストおよびトレーニングの観測の空間的な可視化。ランダム (上段) および空間分割 (下段)。
</p>
</div>
</div>
<div id="spatial-cv-with-mlr3" class="section level2" number="12.5">
<h2>
<span class="header-section-number">12.5</span> <strong>mlr3</strong> を用いた空間交差検証<a class="anchor" aria-label="anchor" href="#spatial-cv-with-mlr3"><i class="fas fa-link"></i></a>
</h2>
<p>
統計的学習のためのパッケージは何十種類もある。例えば <a href="https://CRAN.R-project.org/view=MachineLearning">CRAN machine learning task view</a> で説明されている。
交差検証やハイパーパラメータのチューニング方法など、各パッケージに精通することは時間のかかる作業である。
異なるパッケージのモデル結果を比較するのは、さらに手間がかかる。
これらの問題を解決するために開発されたのが、<strong>mlr3</strong> パッケージとエコシステムである。
これは「メタパッケージ」として機能し、分類、回帰 、生存時間分析、クラスタリングなど、一般的な教師あり・教師なしの統計学習技術への統一的なインタフェースを提供する <span class="citation">(<a href="references.html#ref-lang_mlr3_2019">Lang et al. 2019</a>; <a href="references.html#ref-bischl_applied_2024">Bischl et al. 2024</a>)</span>。
標準化された <strong>mlr3</strong> インターフェースは、8 つの「ビルディングブロック」に基づいている。
Figure <a href="spatial-cv.html#fig:building-blocks">12.4</a> に示すように、これらは明確な順序を持っている。</p>

<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:building-blocks"></span>
<img src="images/12_ml_abstraction_crop.png" alt="mlr3 パッケージの基本的な構成要素 (Bischl et al. 2024)。この図の再利用を快く承諾していただいた。" width="100%"><p class="caption">
FIGURE 12.4: mlr3 パッケージの基本的な構成要素 <span class="citation">(<a href="references.html#ref-bischl_applied_2024">Bischl et al. 2024</a>)</span>。この図の再利用を快く承諾していただいた。
</p>
</div>
<p><strong>mlr3</strong> のモデリングプロセスは、主に3つのステージで構成されている。
まず、<strong>task</strong> で、データ (応答変数と予測変数を含む) とモデルの種類 (回帰や分類など) を指定する。
次に、<strong>learner</strong>は、作成されたタスクに適用される特定の学習アルゴリズムを定義する。
第三に、<strong>リサンプリング</strong>アプローチでは、モデルの予測性能、すなわち新しいデータへの汎化能力を評価する (Section <a href="spatial-cv.html#intro-cv">12.4</a> も参照)。</p>
<div id="glm" class="section level3" number="12.5.1">
<h3>
<span class="header-section-number">12.5.1</span> 一般化線形モデル<a class="anchor" aria-label="anchor" href="#glm"><i class="fas fa-link"></i></a>
</h3>
<p>GLM を <strong>mlr3</strong> で使うためには、地すべりデータを含む <strong>task</strong> を作成する必要がある。
応答は二値 (2 カテゴリの変数) で、空間次元を持つので、<strong>mlr3spatiotempcv</strong> パッケージの <code><a href="https://mlr3spatiotempcv.mlr-org.com/reference/as_task_classif_st.html">as_task_classif_st()</a></code> を使用し、分類タスクを作成する <span class="citation">(<a href="references.html#ref-schratz_mlr3spatiotempcv_2021">Schratz et al. 2021</a> 、非空間 task には <code><a href="https://mlr3.mlr-org.com/reference/as_task_classif.html">mlr3::as_task_classif()</a></code>、回帰には <code><a href="https://mlr3.mlr-org.com/reference/as_task_regr.html">as_task_regr()</a></code> を使用。他の task の詳細は、<code><a href="https://mlr3.mlr-org.com/reference/Task.html">?Task</a></code> を参照。)</span> 。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;strong&gt;mlr3&lt;/strong&gt; エコシステムは &lt;strong&gt;data.table&lt;/strong&gt; と &lt;strong&gt;R6&lt;/strong&gt; というクラスを使用する。これらのクラスの仕様を知らなくても &lt;strong&gt;mlr3&lt;/strong&gt; を使うことはできるが、知っておくと有利である。 &lt;strong&gt;data.table&lt;/strong&gt; の詳細は &lt;a href="https://rdatatable.gitlab.io/data.table/" class="uri"&gt;https://rdatatable.gitlab.io/data.table/&lt;/a&gt;。&lt;strong&gt;R6&lt;/strong&gt; について学びたい方は、&lt;em&gt;Advanced R book&lt;/em&gt; (日本語版は共立出版「R 言語徹底解説」だが、旧版を元にしている) &lt;span class="citation"&gt;(&lt;a href="references.html#ref-wickham_advanced_2019"&gt;Wickham 2019&lt;/a&gt;)&lt;/span&gt; の &lt;a href="https://adv-r.hadley.nz/fp.html"&gt;Chapter 14&lt;/a&gt; を参照。&lt;/p&gt;'><sup>88</sup></a>
<code>as_task_</code> 関数の最初の必須引数は、<code>x</code> である。
<code>x</code> は、入力データが応答変数と予測変数を含んでいることを想定している。
<code>target</code> の引数は応答変数の名前を示し (ここでは <code>lslpts</code>)、<code>positive</code> は応答変数の 2 つの因子レベルのうちどちらが地すべり開始点を示すかを決定する (ここでは <code>TRUE</code>)。
<code>lsl</code> データセットの他のすべての変数が予測因子として機能する。
空間 CV のためには、いくつかの追加引数を与える必要がある。
<code>coordinate_names</code> 引数は、座標列の名前を期待する (Section <a href="spatial-cv.html#intro-cv">12.4</a> と Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> を参照)。
さらに、使用する CRS (<code>crs</code>) を示し、その座標を予測因子としてモデリング (<code>coords_as_features</code>) に使用するかどうかを決定する必要がある。</p>
<div class="sourceCode" id="cb429"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 1. task を作成</span></span>
<span><span class="va">task</span> <span class="op">=</span> <span class="fu">mlr3spatiotempcv</span><span class="fu">::</span><span class="fu"><a href="https://mlr3spatiotempcv.mlr-org.com/reference/as_task_classif_st.html">as_task_classif_st</a></span><span class="op">(</span></span>
<span>  <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/as_data_backend.html">as_data_backend</a></span><span class="op">(</span><span class="va">lsl</span><span class="op">)</span>, </span>
<span>  target <span class="op">=</span> <span class="st">"lslpts"</span>, </span>
<span>  id <span class="op">=</span> <span class="st">"ecuador_lsl"</span>,</span>
<span>  positive <span class="op">=</span> <span class="st">"TRUE"</span>,</span>
<span>  coordinate_names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span>,</span>
<span>  crs <span class="op">=</span> <span class="st">"EPSG:32717"</span>,</span>
<span>  coords_as_features <span class="op">=</span> <span class="cn">FALSE</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>なお、<code><a href="https://mlr3spatiotempcv.mlr-org.com/reference/as_task_classif_st.html">mlr3spatiotempcv::as_task_classif_st()</a></code> は、<code>backend</code> パラメータの入力として <code>sf</code>-オブジェクトも受け付ける。
この場合、引数 <code>coords_as_features</code> のみを追加して指定するとよいだろう。
<code>lsl</code> を <code>sf</code>-オブジェクトに変換しなかったのは、<code><a href="https://mlr3spatiotempcv.mlr-org.com/reference/as_task_classif_st.html">as_task_classif_st()</a></code> がバックグラウンドで非空間的な <code>data.table</code> オブジェクトに戻してしまうだけだからである。</p>
<p>短時間のデータ探索では、<strong>mlr3viz</strong> パッケージの <code><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot()</a></code> 関数は、すべての予測因子に対する応答とすべての予測因子に対する応答をプロットするので便利だろう (図示していない)。</p>
<div class="sourceCode" id="cb430"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 予測因子それぞれに対して応答をプロット</span></span>
<span><span class="fu">mlr3viz</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">task</span>, type <span class="op">=</span> <span class="st">"duo"</span><span class="op">)</span></span>
<span><span class="co"># 変数それぞれに対して相互にプロット</span></span>
<span><span class="fu">mlr3viz</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">task</span>, type <span class="op">=</span> <span class="st">"pairs"</span><span class="op">)</span></span></code></pre></div>
<p>task を作成したら、使用する統計的学習方式を決定する <strong>学習器</strong> (learner) を選択する必要がある。
分類の<strong>学習器</strong> は <code>classif.</code> で始まり、回帰の学習器は <code>regr.</code> で始まる (詳しくは <code><a href="https://mlr3.mlr-org.com/reference/Learner.html">?Learner</a></code> を参照)。
<code><a href="https://rdrr.io/pkg/mlr3extralearners/man/list_mlr3learners.html">mlr3extralearners::list_mlr3learners()</a></code> は、利用可能なすべての学習器と、どのパッケージから <strong>mlr3</strong> がそれらをインポートしているかをリストアップする (Table <a href="spatial-cv.html#tab:lrns">12.3</a>)。
二値応答変数をモデル化できる学習器について調べるには、次のように実行する。</p>
<div class="sourceCode" id="cb431"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">mlr3extralearners</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/mlr3extralearners/man/list_mlr3learners.html">list_mlr3learners</a></span><span class="op">(</span></span>
<span>  filter <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>class <span class="op">=</span> <span class="st">"classif"</span>, properties <span class="op">=</span> <span class="st">"twoclass"</span><span class="op">)</span>, </span>
<span>  select <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"id"</span>, <span class="st">"mlr3_package"</span>, <span class="st">"required_packages"</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rspatial.github.io/terra/reference/headtail.html">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:lrns">TABLE 12.3: </span>パッケージ mlr3 の二項タスク向け にある学習器のサンプル。</caption>
<thead><tr class="header">
<th align="left">Class</th>
<th align="left">Name</th>
<th align="left">Short name</th>
<th align="left">Package</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">classif.adaboostm1</td>
<td align="left">ada Boosting M1</td>
<td align="left">adaboostm1</td>
<td align="left">RWeka</td>
</tr>
<tr class="even">
<td align="left">classif.binomial</td>
<td align="left">二項回帰</td>
<td align="left">binomial</td>
<td align="left">stats</td>
</tr>
<tr class="odd">
<td align="left">classif.featureless</td>
<td align="left">Featureless classifier</td>
<td align="left">featureless</td>
<td align="left">mlr</td>
</tr>
<tr class="even">
<td align="left">classif.fnn</td>
<td align="left">Fast k-Nearest Neighbour</td>
<td align="left">fnn</td>
<td align="left">FNN</td>
</tr>
<tr class="odd">
<td align="left">classif.gausspr</td>
<td align="left">ガウス過程</td>
<td align="left">gausspr</td>
<td align="left">kernlab</td>
</tr>
<tr class="even">
<td align="left">classif.IBk</td>
<td align="left">k-近傍法</td>
<td align="left">ibk</td>
<td align="left">RWeka</td>
</tr>
</tbody>
</table></div>
<p>これにより、すべての学習器が 2 クラス問題 (地すべりの有無) をモデル化することができるようになった。
Section <a href="spatial-cv.html#conventional-model">12.3</a> で使用され、<strong>mlr3learners</strong> では <code>classif.log_reg</code> として実装されている二項分類方式を選択することにする。
さらに、予測の種類を決める <code>predict.type</code> を指定する必要がある。<code>prob</code> は、地すべり発生の予測確率を 0 から 1 の間で決定する (これは <code>type = response</code> の <code><a href="https://rdrr.io/r/stats/predict.glm.html">predict.glm()</a></code> に対応する)。</p>
<div class="sourceCode" id="cb432"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 2. 学習器を指定</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.log_reg"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span></code></pre></div>
<p>学習器のヘルプページにアクセスし、どのパッケージから取得したものかを調べるには、次のように実行する。</p>
<div class="sourceCode" id="cb433"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">learner</span><span class="op">$</span><span class="fu">help</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<!--
学習器とタスクを指定すると、基本的にタスクのバックグラウンドで `glm()` コマンドを実行するモデルを学習させることができる。 


``` r
learner$train(task)
learner$model
```




``` r
fit = glm(lslpts ~ ., family = binomial(link = "logit"), 
          data = select(lsl, -x, -y))
identical(fit$coefficients, learner$model$coefficients)
```
-->
<p><strong>mlr3</strong> でモデリングするためのセットアップ手順は、面倒に思えるだろう。
しかし、この一つのインターフェースで、<code><a href="https://rdrr.io/pkg/mlr3extralearners/man/list_mlr3learners.html">mlr3extralearners::list_mlr3learners()</a></code> が示す 130 種類以上の学習器にアクセスできることを思い出してほしい。各学習器のインターフェースを学ぶことはもっと退屈である。
さらに、リサンプリング技術の簡単な並列化と、機械学習のハイパーパラメータを調整できることも利点である (Section <a href="spatial-cv.html#svm">12.5.2</a> を参照)。
最も重要なことは、<strong>mlr3spatiotempcv</strong> <span class="citation">(<a href="references.html#ref-schratz_mlr3spatiotempcv_2021">Schratz et al. 2021</a>)</span> の (空間) リサンプリングは簡単で、リサンプリング法の指定と実行という 2 つのステップを追加するだけでよいということである。
100 回繰り返される 5 回空間交差検証 : <code>task</code> で提供された座標に基づいて 5 つのパーティションが選ばれ、パーティショニングは 100 回繰り返される。 <a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;なお、パッケージ &lt;strong&gt;sperrorest&lt;/strong&gt; は、当初 R &lt;span class="citation"&gt;(&lt;a href="references.html#ref-brenning_spatial_2012"&gt;Brenning 2012b&lt;/a&gt;)&lt;/span&gt; で空間交差検証を実装していた。
その間に、その機能は &lt;strong&gt;mlr3&lt;/strong&gt; エコシステムに統合された。これが、私たちが &lt;strong&gt;mlr3&lt;/strong&gt; &lt;span class="citation"&gt;(&lt;a href="references.html#ref-schratz_hyperparameter_2019"&gt;Schratz et al. 2019&lt;/a&gt;)&lt;/span&gt; を使用している理由である。&lt;strong&gt;tidymodels&lt;/strong&gt; フレームワークは、R でモデリングを効率化するためのもう一つの包括的パッケージである。しかし、空間交差検証のサポートは、&lt;strong&gt;spatialsample&lt;/strong&gt; を介して最近統合されたが、今のところ一つの空間リサンプリング方法のみをサポートしている。&lt;/p&gt;'><sup>89</sup></a></p>
<div class="sourceCode" id="cb434"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 3. リサンプリングを指定</span></span>
<span><span class="va">resampling</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"repeated_spcv_coords"</span>, folds <span class="op">=</span> <span class="fl">5</span>, repeats <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span></code></pre></div>
<p>空間リサンプリングを実行するために、先に指定したタスク、学習器、リサンプリング戦略を用いて、<code><a href="https://rspatial.github.io/terra/reference/resample.html">resample()</a></code> を実行する。
500 個のリサンプリングパーティションと 500 個のモデルを計算するため、多少時間がかかる (最新のノートパソコンで 15 秒程度)。
性能指標として、今回も AUROC を選択した。
これを取得するために、リサンプリング結果出力オブジェクト (<code>score_spcv_glm</code>) の <code>score()</code> メソッドを使用する。
これは、500 行の <code>data.table</code> オブジェクトを返す。</p>
<div class="sourceCode" id="cb435"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># メッセージを減らす</span></span>
<span><span class="fu">lgr</span><span class="fu">::</span><span class="fu"><a href="https://s-fleck.github.io/lgr/reference/get_logger.html">get_logger</a></span><span class="op">(</span><span class="st">"mlr3"</span><span class="op">)</span><span class="op">$</span><span class="fu">set_threshold</span><span class="op">(</span><span class="st">"warn"</span><span class="op">)</span></span>
<span><span class="co"># 空間交差検証 を実行し、リサンプル結果 glm (rr_glm) に保存</span></span>
<span><span class="va">rr_spcv_glm</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/resample.html">resample</a></span><span class="op">(</span>task <span class="op">=</span> <span class="va">task</span>,</span>
<span>                             learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>                             resampling <span class="op">=</span> <span class="va">resampling</span><span class="op">)</span></span>
<span><span class="co"># AUROC を計算しデータフレームに格納</span></span>
<span><span class="va">score_spcv_glm</span> <span class="op">=</span> <span class="va">rr_spcv_glm</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span>measure <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.auc"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># 必要な列だけ残す</span></span>
<span><span class="va">score_spcv_glm</span> <span class="op">=</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="va">score_spcv_glm</span>, <span class="va">task_id</span>, <span class="va">learner_id</span>, </span>
<span>                               <span class="va">resampling_id</span>, <span class="va">classif.auc</span><span class="op">)</span></span></code></pre></div>
<p>前述のコードチャンクの出力は、モデルの予測性能のバイアスを低減した評価である。
書籍の GitHub リポジトリに <code>extdata/12-bmr_score.rds</code> として保存している。
必要であれば、以下のように読み込むことができる。</p>
<div class="sourceCode" id="cb436"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">score</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/serialize.html">readRDS</a></span><span class="op">(</span><span class="st">"extdata/12-bmr_score.rds"</span><span class="op">)</span></span>
<span><span class="va">score_spcv_glm</span> <span class="op">=</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">score</span>, <span class="va">learner_id</span> <span class="op">==</span> <span class="st">"classif.log_reg"</span>, </span>
<span>                               <span class="va">resampling_id</span> <span class="op">==</span> <span class="st">"repeated_spcv_coords"</span><span class="op">)</span></span></code></pre></div>
<p>全 500 モデルの平均 AUROC を計算するために、以下を実行した。</p>
<div class="sourceCode" id="cb437"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">score_spcv_glm</span><span class="op">$</span><span class="va">classif.auc</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rspatial.github.io/terra/reference/math-generics.html">round</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.77</span></span></code></pre></div>
<p>これらの結果を整理するために、100 回繰り返した 5 回非空間交差検証の AUROC 値と比較してみよう (Figure <a href="spatial-cv.html#fig:boxplot-cv">12.5</a> ; 非空間CVのコードはここでは示さないが、演習セクションで検討する)。
予想通り (Section <a href="spatial-cv.html#intro-cv">12.4</a> 参照)、空間交差検証の結果は、従来の交差検証アプローチよりも平均して低い AUROC 値をもたらし、空間自己相関のため、後者の空間自己相関による楽観的な予測性能が強調された。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:boxplot-cv"></span>
<img src="figures/boxplot-cv-1.png" alt="空間CV と従来の 100 回繰り返し 5 回 CV におけるGLM AUROC 値の差を示す箱ひげ図。" width="75%"><p class="caption">
FIGURE 12.5: 空間CV と従来の 100 回繰り返し 5 回 CV におけるGLM AUROC 値の差を示す箱ひげ図。
</p>
</div>
</div>
<div id="svm" class="section level3" number="12.5.2">
<h3>
<span class="header-section-number">12.5.2</span> 機械学習のハイパーパラメータの空間的チューニング<a class="anchor" aria-label="anchor" href="#svm"><i class="fas fa-link"></i></a>
</h3>
<p>Section <a href="spatial-cv.html#intro-cv">12.4</a> では、統計的学習の一環として、機械学習を導入した。
もう一度確認しよう。<a href="https://machinelearningmastery.com/linear-regression-for-machine-learning/">Jason Brownlee</a> による機械学習の以下の定義に従う。</p>
<blockquote>
<p>機械学習、より具体的には予測モデリングの分野では、説明可能性を犠牲にして、モデルの誤差を最小化すること、あるいは可能な限り正確な予測を行うことに主眼が置かれている。
応用機械学習では、統計学を含む多くの異なる分野からアルゴリズムを借用、再利用、盗用し、こうした目的のために使用する。</p>
</blockquote>
<p>Section <a href="spatial-cv.html#glm">12.5.1</a> では、GLM を用いて地すべりしやすさを予測した。
ここでは、同じ目的のためにサポートベクタマシン (Support Vector Machine, SVM)を紹介する。
ランダムフォレストモデルは SVM よりも人気があるだろう。しかし、ハイパーパラメータのチューニングがモデル性能に与えるプラスの効果は、SVM の場合の方が顕著である <span class="citation">(<a href="references.html#ref-probst_hyperparameters_2018">Probst, Wright, and Boulesteix 2018</a>)</span>。
本節では、 (空間) ハイパーパラメータのチューニングが主な目的であるため、SVM を用いることにする。
ランダムフォレストモデルを適用したい方は、この章を読んでから Chapter <a href="eco.html#eco">15</a> に進むことを勧める。この章では、現在取り上げられている概念と技術を応用して、ランダムフォレストモデルに基づく空間分布図を作成する方法を説明する。</p>
<p>SVM クラスを分離するための最適な「超平面」を探索し (分類 の場合)、特定のハイパーパラメータで「カーネル」を推定して、クラス間の非線形境界を作成する <span class="citation">(<a href="references.html#ref-james_introduction_2013">James et al. 2013</a>)</span>。
機械学習には、ハイパーパラメータとパラメータがある。
パラメータはデータから推定できるが、ハイパーパラメータは学習開始前に設定しなければならない (mlr3 本の<a href="https://machinelearningmastery.com/difference-between-a-parameter-and-a-hyperparameter/">machine mastery blog</a>と<a href="https://mlr3book.mlr-org.com/chapters/chapter4/hyperparameter_optimization.html">hyperparameter optimization chapter</a> も参照)。
最適なハイパーパラメータは、通常、交差検証法を用いて定義された範囲内で決定する。
これをハイパーパラメータチューニングという。</p>
<p><strong>kernlab</strong> が提供 SVM 実装の中には、ハイパーパラメータを自動的に、通常はランダムなサンプルに基づいて調整することができるものもある (Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> の上段を参照)。
これは非空間データでは有効だが、空間データではあまり意味がなく、「空間チューニング」を行う必要がある。</p>
<p>空間チューニングを定義する前に、Section <a href="spatial-cv.html#glm">12.5.1</a> で紹介した <strong>mlr3</strong> ビルディングブロックを SVM 用に設定することにする。
分類のタスクは変わらないので、Section <a href="spatial-cv.html#glm">12.5.1</a> で作成した <code>task</code> オブジェクトを再利用すればよい。
SVM を実装している学習器は、<strong>mlr3extralearners</strong> パッケージの <code>listLearners()</code> を用いて検索することができる。</p>
<div class="sourceCode" id="cb438"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mlr3_learners</span> <span class="op">=</span> <span class="fu">mlr3extralearners</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/mlr3extralearners/man/list_mlr3learners.html">list_mlr3learners</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; This will take a few seconds.</span></span>
<span><span class="va">mlr3_learners</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">class</span> <span class="op">==</span> <span class="st">"classif"</span> <span class="op">&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">grepl</a></span><span class="op">(</span><span class="st">"svm"</span>, <span class="va">id</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="va">id</span>, <span class="va">class</span>, <span class="va">mlr3_package</span>, <span class="va">required_packages</span><span class="op">)</span></span>
<span><span class="co">#&gt;               id   class      mlr3_package              required_packages</span></span>
<span><span class="co">#&gt;           &lt;char&gt;  &lt;char&gt;            &lt;char&gt;                         &lt;list&gt;</span></span>
<span><span class="co">#&gt; 1:  classif.ksvm classif mlr3extralearners mlr3,mlr3extralearners,kernlab</span></span>
<span><span class="co">#&gt; 2: classif.lssvm classif mlr3extralearners mlr3,mlr3extralearners,kernlab</span></span>
<span><span class="co">#&gt; 3:   classif.svm classif      mlr3learners        mlr3,mlr3learners,e1071</span></span></code></pre></div>
<p>オプションのうち、<strong>kernlab</strong> パッケージの <code>ksvm()</code> を使用することにする <span class="citation">(<a href="references.html#ref-karatzoglou_kernlab_2004">Karatzoglou et al. 2004</a>)</span>。
非線形関係を許容するために、<code>ksvm()</code> のデフォルトでもある、一般的な放射状基底関数 (またはガウス) カーネル (<code>"rbfdot"</code>) を使用する。
<code>type</code> 引数に <code>"C-svc"</code> を設定することで、<code>ksvm()</code> が確実に分類タスクを解く。
1 つのモデルの失敗でチューニングが止まらないように、フォールバック学習器を追加で定義している (詳細は <a href="https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-fallback" class="uri">https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-fallback</a> を参照)。</p>
<div class="sourceCode" id="cb439"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lrn_ksvm</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.ksvm"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span>, kernel <span class="op">=</span> <span class="st">"rbfdot"</span>,</span>
<span>                     type <span class="op">=</span> <span class="st">"C-svc"</span><span class="op">)</span></span>
<span><span class="va">lrn_ksvm</span><span class="op">$</span><span class="fu">encapsulate</span><span class="op">(</span>method <span class="op">=</span> <span class="st">"try"</span>, </span>
<span>                     fallback <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.featureless"</span>, </span>
<span>                                    predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>次の段階は、リサンプリング戦略を指定することである。
ここでも 100 回繰り返しの 5 回空間交差検証を使用する。</p>
<div class="sourceCode" id="cb440"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># パフォーマンス推定レベル</span></span>
<span><span class="va">perf_level</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"repeated_spcv_coords"</span>, folds <span class="op">=</span> <span class="fl">5</span>, repeats <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span></code></pre></div>
<p>これは Section <a href="spatial-cv.html#glm">12.5.1</a> の GLM のリサンプリングに使われたコードと全く同じであることに注意しておこう。</p>
<p>ここまでは、Section <a href="spatial-cv.html#glm">12.5.1</a> で説明したものと同じである。
しかし、次のステップは新しく、ハイパーパラメータ を調整する。
性能評価とチューニングに同じデータを使用すると、楽観的すぎる結果になる可能性がある <span class="citation">(<a href="references.html#ref-cawley_overfitting_2010">Cawley and Talbot 2010</a>)</span>。
これは、ネストされた空間交差検証 を用いることで回避することができる。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:inner-outer"></span>
<img src="images/12_cv.png" alt="CV におけるハイパーパラメータのチューニングと性能推定レベルの模式図 (図は Schratz et al. (2019) から引用した。快く再利用の許可をいただいた)。" width="100%"><p class="caption">
FIGURE 12.6: CV におけるハイパーパラメータのチューニングと性能推定レベルの模式図 (図は Schratz et al. (2019) から引用した。快く再利用の許可をいただいた)。
</p>
</div>
<p>これは、各フォールドを空間的に不連続な 5 つのサブフォールドに再び分割し、最適なハイパーパラメータ (<code>tune_level</code> 以下のコードチャンクのオブジェクト。視覚的表現については Figure <a href="spatial-cv.html#fig:inner-outer">12.6</a> を参照) を決定するために使用することを意味する。
さらに、値 C と Sigma のランダムな選択は、あらかじめ定義された調整空間 (<code>search_space</code> オブジェクト) に制限されている。
同調空間の範囲は、文献で推奨されている値で選択した <span class="citation">(<a href="references.html#ref-schratz_hyperparameter_2019">Schratz et al. 2019</a>)</span>。
最適なハイパーパラメータの組み合わせを見つけるために、これらのサブフォルダそれぞれにおいて、ハイパーパラメータ C とシグマにランダムな値を選択して 50 のモデル (以下のコードチャンクの <code>terminator</code> オブジェクト) を適合させた。</p>
<div class="sourceCode" id="cb441"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># ５つに分割</span></span>
<span><span class="va">tune_level</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"spcv_coords"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="co"># ランダムに選択されたハイパーパラメータの限界値を定義</span></span>
<span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">paradox</span><span class="fu">::</span><span class="fu"><a href="https://paradox.mlr-org.com/reference/ps.html">ps</a></span><span class="op">(</span></span>
<span>  C <span class="op">=</span> <span class="fu">paradox</span><span class="fu">::</span><span class="fu"><a href="https://paradox.mlr-org.com/reference/Domain.html">p_dbl</a></span><span class="op">(</span>lower <span class="op">=</span> <span class="op">-</span><span class="fl">12</span>, upper <span class="op">=</span> <span class="fl">15</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fl">2</span><span class="op">^</span><span class="va">x</span><span class="op">)</span>,</span>
<span>  sigma <span class="op">=</span> <span class="fu">paradox</span><span class="fu">::</span><span class="fu"><a href="https://paradox.mlr-org.com/reference/Domain.html">p_dbl</a></span><span class="op">(</span>lower <span class="op">=</span> <span class="op">-</span><span class="fl">15</span>, upper <span class="op">=</span> <span class="fl">6</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fl">2</span><span class="op">^</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># 50 個のランダムに選択されたハイパーパラメータを使用</span></span>
<span><span class="va">terminator</span> <span class="op">=</span> <span class="fu">mlr3tuning</span><span class="fu">::</span><span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">50</span><span class="op">)</span></span>
<span><span class="va">tuner</span> <span class="op">=</span> <span class="fu">mlr3tuning</span><span class="fu">::</span><span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html">tnr</a></span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span></span></code></pre></div>
<p>次の段階は、<code><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html">auto_tuner()</a></code> を用いてハイパーパラメータチューニングを定義するすべての特性に従って学習器 <code>lrn_ksvm</code> を修正することである。</p>
<div class="sourceCode" id="cb442"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">at_ksvm</span> <span class="op">=</span> <span class="fu">mlr3tuning</span><span class="fu">::</span><span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html">auto_tuner</a></span><span class="op">(</span></span>
<span>  learner <span class="op">=</span> <span class="va">lrn_ksvm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">tune_level</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.auc"</span><span class="op">)</span>,</span>
<span>  search_space <span class="op">=</span> <span class="va">search_space</span>,</span>
<span>  terminator <span class="op">=</span> <span class="va">terminator</span>,</span>
<span>  tuner <span class="op">=</span> <span class="va">tuner</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>このチューニングは、1 つのフォールドに対して最適なハイパーパラメータを決定するために、250 のモデルを適合させるように設定されている。
これを 1 回ずつ繰り返すと、1,250 個 (250 * 5) のモデルができあがる。
100 回繰り返すということは、合計 125,000 個のモデルを適合して最適なハイパーパラメータ( Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> )を特定することになる。
これを性能推定に使用し、さらに 500 個のモデル (5 folds * 100 repetitions; Figure <a href="spatial-cv.html#fig:partitioning">12.3</a> 参照) の適合が必要である。
性能推定処理の連鎖をさらにわかりやすくするために、コンピュータに与えた命令を書き出してみよう。</p>
<ol style="list-style-type: decimal">
<li>パフォーマンスレベル ( Figure <a href="spatial-cv.html#fig:inner-outer">12.6</a> の左上部分) - データセットを 5 つの空間的に不連続な (外側の) サブフォールドに分割する。</li>
<li>チューニング・レベル ( Figure <a href="spatial-cv.html#fig:inner-outer">12.6</a> の左下部分) - パフォーマンス・レベルの最初のフォールドを使用し、ハイパーパラメータのチューニングのために、それを再び 5 つの (内側の) サブフォールドに空間的に分割する。 これらの内部サブフォールドのそれぞれで、ランダムに選択された 50 個のハイパーパラメータを使用する、つまり、250 個のモデルを適合させる。</li>
<li>性能推定 - 前のステップ (チューニング・レベル) から最適なハイパーパラメータの組み合わせを使用し、性能レベルの最初の外側のフォールドに適用して性能を推定する (AUROC )。</li>
<li>残りの 4 つの外側のフォールドについて、手順 2 と 3 を繰り返す</li>
<li>手順 2～4 を 100 回繰り返す</li>
</ol>
<p>ハイパーパラメータのチューニングと性能推定のプロセスには、計算量が必要である。
モデルの実行時間を短縮するために、<strong>mlr3</strong> では、<strong>future</strong> パッケージの助けを借りて、並列化を使用する可能性を提供している。
これからネストした CV を実行するので、内側ループと外側ループのどちらを並列化するか決めることができる (Figure <a href="spatial-cv.html#fig:inner-outer">12.6</a> の左下部分を参照)。
前者は 125,000 個のモデルを実行するのに対し、後者は 500 個しか実行しないので、内側のループを並列化するのは当然である。
内側のループの並列化を設定するために、実行する。</p>
<div class="sourceCode" id="cb443"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://future.futureverse.org">future</a></span><span class="op">)</span></span>
<span><span class="co"># 外側のループを順次実行し、内側のループを並列化する。</span></span>
<span><span class="fu">future</span><span class="fu">::</span><span class="fu"><a href="https://future.futureverse.org/reference/plan.html">plan</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="st">"sequential"</span>, <span class="st">"multisession"</span><span class="op">)</span>, </span>
<span>             workers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="fu"><a href="https://parallelly.futureverse.org/reference/availableCores.html">availableCores</a></span><span class="op">(</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>さらに、<strong>future</strong> には、利用可能なすべてのコア (デフォルト) ではなく、半分だけを使用するように指示した。これは、1 つのコアを使用する場合に、他のユーザーが同じ高性能計算機クラスタで作業する可能性を考慮した設定である。</p>
<p>これで、ネストされた空間交差検証を計算するための準備ができた。
<code><a href="https://rspatial.github.io/terra/reference/resample.html">resample()</a></code> パラメータの指定は、GLM を使用したときと全く同じ手順で行う。唯一の違いは、<code>store_models</code> と <code>encapsulate</code> の引数である。
前者を <code>TRUE</code> に設定すると、ハイパーパラメータのチューニング結果を抽出できる。これは、チューニングに関するフォローアップ分析を計画する場合に重要である。
後者は、モデルの 1 つがエラーを投げても処理が継続されるようにするものである。
これにより、1 つのモデルが失敗しただけで処理が停止することを避けることができ、大規模なモデルの実行には望ましい。
処理が完了すると、故障したモデルを見ることができる。
処理終了後、<code>future::ClusterRegistry("stop")</code> で明示的に並列化を停止するのがよいだろう。
最後に、出力オブジェクト (<code>result</code>) を、別の R セッションで使用する場合に備えてディスクに保存する。
125,500 個のモデルで空間交差検証を行うため、時間がかかることをご了承の上、実行してみよう。
現代のコンピュータで、たった半日で実行できる。
実行時間は、CPU 速度、選択したアルゴリズム、選択したコア数、データセットなど多くの側面に依存することに注意しておこう。</p>
<div class="sourceCode" id="cb444"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">progressr</span><span class="fu">::</span><span class="fu"><a href="https://progressr.futureverse.org/reference/with_progress.html">with_progress</a></span><span class="op">(</span>expr <span class="op">=</span> <span class="op">{</span></span>
<span>  <span class="va">rr_spcv_svm</span> <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/resample.html">resample</a></span><span class="op">(</span>task <span class="op">=</span> <span class="va">task</span>,</span>
<span>                               learner <span class="op">=</span> <span class="va">at_ksvm</span>, </span>
<span>                               <span class="co"># 外側リサンプリング (パフォーマンスレベル) </span></span>
<span>                               resampling <span class="op">=</span> <span class="va">perf_level</span>,</span>
<span>                               store_models <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                               encapsulate <span class="op">=</span> <span class="st">"evaluate"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="co"># 並列化を終了</span></span>
<span><span class="fu">future</span><span class="fu">:::</span><span class="fu">ClusterRegistry</span><span class="op">(</span><span class="st">"stop"</span><span class="op">)</span></span>
<span><span class="co"># AUROC 値を計算</span></span>
<span><span class="va">score_spcv_svm</span> <span class="op">=</span> <span class="va">rr_spcv_svm</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span>measure <span class="op">=</span> <span class="fu">mlr3</span><span class="fu">::</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.auc"</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span></span>
<span><span class="co"># 必要な列のみ残す</span></span>
<span><span class="va">score_spcv_svm</span> <span class="op">=</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="va">score_spcv_svm</span>, <span class="va">task_id</span>, <span class="va">learner_id</span>, </span>
<span>                               <span class="va">resampling_id</span>, <span class="va">classif.auc</span><span class="op">)</span></span></code></pre></div>
<p>ローカルでコードを実行したくない方のために、書籍の GitHub リポジトリに <a href="https://github.com/geocompx/geocompr/blob/main/extdata/12-bmr_score.rds">score_svm</a> を保存してある。
以下のように読み込むことができる。</p>
<div class="sourceCode" id="cb445"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">score</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/serialize.html">readRDS</a></span><span class="op">(</span><span class="st">"extdata/12-bmr_score.rds"</span><span class="op">)</span></span>
<span><span class="va">score_spcv_svm</span> <span class="op">=</span> <span class="va">score</span><span class="op">[</span><span class="va">learner_id</span> <span class="op">==</span> <span class="st">"classif.ksvm.tuned"</span> <span class="op">&amp;</span> </span>
<span>                         <span class="va">resampling_id</span> <span class="op">==</span> <span class="st">"repeated_spcv_coords"</span><span class="op">]</span></span></code></pre></div>
<p>最終的な AUROC: モデルが 2 つのクラスを識別する能力を見てみよう。</p>
<div class="sourceCode" id="cb446"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 最終的な AUROC 平均</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/math-generics.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">score_spcv_svm</span><span class="op">$</span><span class="va">classif.auc</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.74</span></span></code></pre></div>
<p>GLM は、この特定のケースでは、SVM よりもわずかに優れているようである (集計された AUROC は 0.77)。
絶対的に公平な比較を保証するためには、2 つのモデルが全く同じパーティションを使用していることを確認する必要がある。ここでは示していないが、バックグラウンドで黙々と使用しているものである (詳しくは本書の GitHub リポジトリにある <code>code/12_cv.R</code> を参照)。
そのために、<strong>mlr3</strong> は関数 <code><a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html">benchmark_grid()</a></code> と <code><a href="https://mlr3.mlr-org.com/reference/benchmark.html">benchmark()</a></code> を提供している <span class="citation">(<a href="https://mlr3book.mlr-org.com/chapters/chapter3/evaluation_and_benchmarking.html#sec-benchmarking" class="uri">https://mlr3book.mlr-org.com/chapters/chapter3/evaluation_and_benchmarking.html#sec-benchmarking</a>, <a href="references.html#ref-bischl_applied_2024">Bischl et al. 2024</a> 参照)</span> 。
これらの機能については、「演習」でより詳しく解説する。
また、SVM のランダムな探索に 50 回以上の反復を使用すると、おそらくより良い AUROC <span class="citation">(<a href="references.html#ref-schratz_hyperparameter_2019">Schratz et al. 2019</a>)</span> を持つモデルになるハイパーパラメータが得られるであろうことに注意しておこう。
一方、ランダムサーチの反復回数を増やすと、モデルの総数も増え、その分実行時間も長くなる。</p>
<p>これまで、空間交差検証 は、学習アルゴリズムが未知のデータに対して汎化する能力を評価するために利用されていた。
空間分布図作成では、完全なデータセットでハイパーパラメータを調整する。
これについては、Chapter <a href="eco.html#eco">15</a> で説明する。</p>
</div>
</div>
<div id="conclusions" class="section level2" number="12.6">
<h2>
<span class="header-section-number">12.6</span> 結論<a class="anchor" aria-label="anchor" href="#conclusions"><i class="fas fa-link"></i></a>
</h2>
<p>リサンプリング手法は、データサイエンティストのツールボックスの重要なものの一つである <span class="citation">(<a href="references.html#ref-james_introduction_2013">James et al. 2013</a>)</span>。
この章では、CV を用いて、様々なモデルの予測性能を評価した。
Section <a href="spatial-cv.html#intro-cv">12.4</a> で述べたように、空間座標を持つ観測は、空間自己相関のために統計的に独立でない場合があり、交差検証の基本的な仮定に違反する。
空間交差検証 この問題は、空間的自己相関によってもたらされるバイアスを低減することで解決される。</p>
<p><strong>mlr3</strong> パッケージは、線形回帰、一般化加法モデルなどのセミパラメトリックモデルなどの統計学習、あるいはランダムフォレスト、SVM 、ブースト回帰木 <span class="citation">(<a href="references.html#ref-bischl_mlr:_2016">Bischl et al. 2016</a>; <a href="references.html#ref-schratz_hyperparameter_2019">Schratz et al. 2019</a>)</span> などの機械学習 技術と組み合わせることで、 (空間) リサンプリング技法を容易にしている。
機械学習アルゴリズムは、ハイパーパラメータの入力を必要とすることがある。その最適な「チューニング」には、大規模な計算資源を必要とする数千回のモデル実行が必要で、多くの時間、RAM、コアを消費することがある。
<strong>mlr3</strong> は、並列化を可能にすることでこの問題に取り組んでいる。</p>
<p>機械学習全体、そして空間データを理解するための機械学習は大きな分野であり、この章では基本的なことを説明したが、まだまだ学ぶべきことはある。
このような方向性で、以下の資料を勧める。</p>
<ul>
<li>
<strong>mlr3 book</strong> (<span class="citation">Bischl et al. (<a href="references.html#ref-bischl_applied_2024">2024</a>)</span>; <a href="https://mlr3book.mlr-org.com/" class="uri">https://mlr3book.mlr-org.com/</a>) と、特に <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#spatiotemp-cv">chapter on the handling of spatio-temporal data</a> を参考。</li>
<li>ハイパーパラメータチューニングに関する学術論文 <span class="citation">(<a href="references.html#ref-schratz_hyperparameter_2019">Schratz et al. 2019</a>)</span>
</li>
<li>
<strong>mlr3spatiotempcv</strong> の使用方法に関する学術論文 <span class="citation">(<a href="references.html#ref-schratz_mlr3spatiotempcv_2021">Schratz et al. 2021</a>)</span>
</li>
<li>時空間データの場合、空間的と時間的の自己相関を考慮した上で CV を行う必要がある <span class="citation">(<a href="references.html#ref-meyer_improving_2018">Meyer et al. 2018</a>)</span>。</li>
</ul>
</div>
<div id="演習-9" class="section level2" number="12.7">
<h2>
<span class="header-section-number">12.7</span> 演習<a class="anchor" aria-label="anchor" href="#%E6%BC%94%E7%BF%92-9"><i class="fas fa-link"></i></a>
</h2>
<p>E1. <code>terra::rast(system.file("raster/ta.tif", package = "spDataLarge"))$elev</code> で読み込んだ <code>elev</code> データセットから、R-GIS ブリッジ (GIS ソフトウェアへのブリッジの章を参照) を用いて以下の地形属性を計算しなさい。</p>
<ul>
<li>傾斜角度</li>
<li>平面曲率</li>
<li>プロファイル曲率</li>
<li>集水域</li>
</ul>
<p>E2. <code>slope</code>、<code>cplan</code>、<code>cprof</code>、<code>elev</code>、<code>log_carea</code> という新しい変数を追加し、対応する出力ラスタから <code>lsl</code> データフレーム (<code>data("lsl", package = "spDataLarge"</code>)) に値を抽出しなさい。</p>
<p>E3. 導き出された地形属性ラスタを GLM と組み合わせて、Figure 12.2に示すような空間予測マップを作成しなさい。
<code>data("study_mask", "package="spDataLarge")</code> を実行すると、調査地域のマスクが添付される。</p>
<p>E4. GLM 学習器に基づき、100 回繰り返した 5 フォールドの非空間交差検証と空間交差検証を計算し、箱ひげ図を用いて両方のリサンプリング戦略からの AUROC 値を比較しなさい。</p>
<p>ヒント: 非空間リサンプリング戦略を指定する必要がある。</p>
<p>追加ヒント: <code><a href="https://mlr3.mlr-org.com/reference/benchmark.html">mlr3::benchmark()</a></code> と <code><a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html">mlr3::benchmark_grid()</a></code> を使って、練習問題 4 から 6 を一度に解くことができます (詳しくは <a href="https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-fallback" class="uri">https://mlr3book.mlr-org.com/chapters/chapter10/advanced_technical_aspects_of_mlr3.html#sec-fallback</a> を参照)。
その際、計算には非常に時間がかかり、おそらく数日かかることを覚悟しよう。
もちろん、これはシステムに依存する。
自由に使える RAM とコアが多ければ多いほど、計算時間は短くなる。</p>
<p>E5. 二次判別分析 (quadratic discriminant analysis, QDA) を用いて地すべり感受性をモデル化しなさい。
QDA の予測性能を評価しなさい。
QDA と GLM の空間交差検証平均 AUROC 値の差は?</p>
<p>E6. ハイパーパラメータを調整せずに SVM を実行しなさい。
<code>rbfdot</code> カーネルを <span class="math inline">\(sigma\)</span> = 1 と <em>C</em> = 1 で使用しなさい。
<strong>kernlab</strong> の <code>ksvm()</code> でハイパーパラメータを指定しないままにしておくと、自動的に非空間的なハイパーパラメータチューニングが初期化しなさい。</p>

</div>
</div>




  <div class="chapter-nav">
<div class="prev"><a href="algorithms.html"><span class="header-section-number">11</span> スクリプト、アルゴリズム、関数</a></div>
<div class="next"><a href="transport.html"><span class="header-section-number">13</span> 交通解析</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Second Edition</h2>
    <!--<p>Now is a great time to provide feedback</p>-->
        <ul class="list-unstyled">
<!--<li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Provide feedback (5 min)</a></li>--><li><a href="https://geocompx.org/">Visit the geocompx website 🌐</a></li>
          <li><a href="https://r.geocompx.org/#reproducibility">Install updated packages 💾</a></li>
          <li><a href="https://github.com/geocompx/geocompr/issues">Open an issue <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Chat on Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://r.geocompx.org/solutions/">Check exercise solutions <i class="fa fa-check"></i></a></li>
          <li><a href="https://supportukrainenow.org/">Support Ukraine 🇺🇦
</a></li>
          <li><a href="https://donate.stripe.com/4gweWl94Q9E35AQ6oo">Support this project 💸</a></li>
        </ul>
<div class="LECTURE_IN_JAPANESE" style="border:solid 1px;border-color:#be1558;background:#fbcbc9"><a href="https://peatix.com/group/16401222" target="_blank">2025年4月頃より、レクチャーを計画しています。Peatix でフォローしてください。</a></div>
        <hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#spatial-cv"><span class="header-section-number">12</span> 統計的学習</a></li>
<li><a class="nav-link" href="#prerequisites-12">必須パッケージ</a></li>
<li><a class="nav-link" href="#intro-cv1"><span class="header-section-number">12.1</span> イントロダクション</a></li>
<li><a class="nav-link" href="#case-landslide"><span class="header-section-number">12.2</span> ケーススタディ: 地すべりの発生しやすさ</a></li>
<li><a class="nav-link" href="#conventional-model"><span class="header-section-number">12.3</span> R による従来のモデリング手法</a></li>
<li><a class="nav-link" href="#intro-cv"><span class="header-section-number">12.4</span> (空間) 交差検証の紹介</a></li>
<li>
<a class="nav-link" href="#spatial-cv-with-mlr3"><span class="header-section-number">12.5</span> mlr3 を用いた空間交差検証</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#glm"><span class="header-section-number">12.5.1</span> 一般化線形モデル</a></li>
<li><a class="nav-link" href="#svm"><span class="header-section-number">12.5.2</span> 機械学習のハイパーパラメータの空間的チューニング</a></li>
</ul>
</li>
<li><a class="nav-link" href="#conclusions"><span class="header-section-number">12.6</span> 結論</a></li>
<li><a class="nav-link" href="#%E6%BC%94%E7%BF%92-9"><span class="header-section-number">12.7</span> 演習</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompx/geocompr/blob/main/12-spatial-cv-ja.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompx/geocompr/edit/main/12-spatial-cv-ja.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation with R</strong>" was written by Robin Lovelace, Jakub Nowosad, Jannes Muenchow. It was last built on 2025-06-13.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
