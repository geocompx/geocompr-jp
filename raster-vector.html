<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 6 ラスタとベクタの相互作用 | Geocomputation with R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="必須パッケージ この章では、以下のパッケージが必要である。 library(sf) library(terra) library(dplyr)  6.1 イントロダクション  この章では、Chapter 2 で紹介したラスタとベクタの地理データモデル間の相互作用に焦点を当てる。 主要な技法をいくつか紹介する。 最初は、ベクタオブジェクトを使用したラスタの切り落とし (crop) とマスク...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 6 ラスタとベクタの相互作用 | Geocomputation with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://r.geocompx.org/jp/raster-vector.html">
<meta property="og:image" content="https://r.geocompx.org/jp/images/cover2.png">
<meta property="og:description" content="必須パッケージ この章では、以下のパッケージが必要である。 library(sf) library(terra) library(dplyr)  6.1 イントロダクション  この章では、Chapter 2 で紹介したラスタとベクタの地理データモデル間の相互作用に焦点を当てる。 主要な技法をいくつか紹介する。 最初は、ベクタオブジェクトを使用したラスタの切り落とし (crop) とマスク...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 6 ラスタとベクタの相互作用 | Geocomputation with R">
<meta name="twitter:description" content="必須パッケージ この章では、以下のパッケージが必要である。 library(sf) library(terra) library(dplyr)  6.1 イントロダクション  この章では、Chapter 2 で紹介したラスタとベクタの地理データモデル間の相互作用に焦点を当てる。 主要な技法をいくつか紹介する。 最初は、ベクタオブジェクトを使用したラスタの切り落とし (crop) とマスク...">
<meta name="twitter:image" content="https://r.geocompx.org/jp/images/cover2.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.10/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.10/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.10/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><meta name="citation_title" content="Chapter 6 ラスタとベクタの相互作用 | Geocomputation with R">
<meta name="citation_author" content="Robin Lovelace">
<meta name="citation_author" content="Jakub Nowosad">
<meta name="citation_author" content="Jannes Muenchow">
<meta name="citation_publication_date" content="2019">
<meta name="citation_isbn" content="9780203730058">
<link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">
<script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.2.2/leaflet.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDC2S0ZNH5"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VDC2S0ZNH5');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ようこそ</a></li>
<li><a class="" href="foreword-1st-edition.html">序文 (第 1 版)</a></li>
<li><a class="" href="forward-2nd-edition.html">序文 (第 2 版)</a></li>
<li><a class="" href="preface.html">序文</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> はじめに</a></li>
<li class="book-part">基本機能</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> 地理データと R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> 属性データ操作</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> 空間データ操作</a></li>
<li><a class="" href="geometry-operations.html"><span class="header-section-number">5</span> ジオメトリ演算</a></li>
<li><a class="active" href="raster-vector.html"><span class="header-section-number">6</span> ラスタとベクタの相互作用</a></li>
<li><a class="" href="reproj-geo-data.html"><span class="header-section-number">7</span> 地理データの再投影</a></li>
<li><a class="" href="read-write.html"><span class="header-section-number">8</span> 地理データI/O</a></li>
<li class="book-part">拡張機能</li>
<li><a class="" href="adv-map.html"><span class="header-section-number">9</span> R で地図を作成</a></li>
<li><a class="" href="gis.html"><span class="header-section-number">10</span> GIS ソフトウェアへのブリッジ</a></li>
<li><a class="" href="algorithms.html"><span class="header-section-number">11</span> スクリプト、アルゴリズム、関数</a></li>
<li><a class="" href="spatial-cv.html"><span class="header-section-number">12</span> 統計的学習</a></li>
<li class="book-part">応用</li>
<li><a class="" href="transport.html"><span class="header-section-number">13</span> 交通解析</a></li>
<li><a class="" href="location.html"><span class="header-section-number">14</span> 商圏分析</a></li>
<li><a class="" href="eco.html"><span class="header-section-number">15</span> 生態学</a></li>
<li><a class="" href="conclusion.html"><span class="header-section-number">16</span> 結論</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompx/geocompr">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="raster-vector" class="section level1" number="6">
<h1>
<span class="header-section-number">6</span> ラスタとベクタの相互作用<a class="anchor" aria-label="anchor" href="#raster-vector"><i class="fas fa-link"></i></a>
</h1>
<div id="prerequisites-06" class="section level2 unnumbered">
<h2>必須パッケージ<a class="anchor" aria-label="anchor" href="#prerequisites-06"><i class="fas fa-link"></i></a>
</h2>
<p>この章では、以下のパッケージが必要である。</p>
<div class="sourceCode" id="cb203"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/">terra</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org">dplyr</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div id="introduction-06" class="section level2" number="6.1">
<h2>
<span class="header-section-number">6.1</span> イントロダクション<a class="anchor" aria-label="anchor" href="#introduction-06"><i class="fas fa-link"></i></a>
</h2>
<p>
この章では、Chapter <a href="spatial-class.html#spatial-class">2</a> で紹介したラスタとベクタの地理データモデル間の相互作用に焦点を当てる。
主要な技法をいくつか紹介する。
最初は、ベクタオブジェクトを使用したラスタの切り落とし (crop) とマスク (mask) から始める (Section <a href="raster-vector.html#raster-cropping">6.2</a>)。
次に、さまざまな種類のベクタデータを使ってラスタ値を抽出する (Section <a href="raster-vector.html#raster-extraction">6.3</a>)。
最後は、ラスタベクタ変換である (Section <a href="raster-vector.html#rasterization">6.4</a> と Section <a href="raster-vector.html#spatial-vectorization">6.5</a>)。
以上の概念を、実世界でどのように応用できるかを理解するため、これまでの章で使用したデータを用いて実際に操作していく。</p>
</div>
<div id="raster-cropping" class="section level2" number="6.2">
<h2>
<span class="header-section-number">6.2</span> ラスタの切り落とし (crop)<a class="anchor" aria-label="anchor" href="#raster-cropping"><i class="fas fa-link"></i></a>
</h2>
<p>
多くの地理データプロジェクトでは、リモートセンシング画像 (ラスタ) や行政境界線 (ベクタ) など、さまざまなソースからのデータを統合している。
入力されたラスタデータセットの範囲は、対象地域よりも大きいことがよくある。
この場合、入力データの空間的な広がりを統一するために、ラスタの<strong>切り落とし</strong> (crop) や<strong>マスク</strong> (mask) が有効である。
この 2 つの処理により、オブジェクトのメモリ使用量と、その後の解析に必要な計算資源を削減できる。ラスタデータを含む魅力的な地図を作成する際に必要な前処理工程となる場合がある。</p>
<p>ここでは、2 つのオブジェクトを使ってラスタ切り落としを説明する。</p>
<ul>
<li>
<code>SpatRaster</code> のオブジェクト <code>srtm</code> は、米国 Utah 州南西部の標高 (海抜メートル) を表す。</li>
<li>ベクタ (<code>sf</code>) オブジェクト <code>zion</code> は、Zion 国立公園 (Zion National Park) を表す。</li>
</ul>
<p>ターゲットと切り取りオブジェクトの両方が同じ投影である必要がある。
したがって、以下のコードは Chapter <a href="spatial-class.html#spatial-class">2</a> でインストールされた <strong>spDataLarge</strong> パッケージからデータセットを読み込むだけでなく、<code>zion</code> を「再投影」している (この話題は Chapter <a href="reproj-geo-data.html#reproj-geo-data">7</a> で取り上げている)。</p>
<div class="sourceCode" id="cb204"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">srtm</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">zion</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"vector/zion.gpkg"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">zion</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">zion</span>, <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">srtm</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><code>srtm</code> のラスタを切り出すために <strong>terra</strong> パッケージの <code><a href="https://rspatial.github.io/terra/reference/crop.html">crop()</a></code> を使用する。
この関数は、第 1 引数に渡されたオブジェクトの矩形範囲を、第 2 引数に渡されたオブジェクトの範囲に縮小する。
つまり、以下のコマンドで Figure <a href="raster-vector.html#fig:cropmask">6.1</a> (B) を生成する。</p>
<div class="sourceCode" id="cb205"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">srtm_cropped</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/crop.html">crop</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion</span><span class="op">)</span></span></code></pre></div>
<p>
<code><a href="https://rspatial.github.io/terra/reference/crop.html">crop()</a></code> に関連するものとして、<strong>terra</strong> 関数 <code><a href="https://rspatial.github.io/terra/reference/mask.html">mask()</a></code> がある。これは第 2 引数に渡されたオブジェクトの境界外の値を <code>NA</code> に設定するものである。
したがって、次のコマンドは、Zion 国立公園の境界の外側のすべてのセルをマスクする (Figure <a href="raster-vector.html#fig:cropmask">6.1</a> (C))。</p>
<div class="sourceCode" id="cb206"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">srtm_masked</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/mask.html">mask</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion</span><span class="op">)</span></span></code></pre></div>
<p><code><a href="https://rspatial.github.io/terra/reference/crop.html">crop()</a></code> と <code><a href="https://rspatial.github.io/terra/reference/mask.html">mask()</a></code> は、一緒に使うことが多い。
(a) ラスタの範囲を目的の領域に限定し、(b) 領域外の値をすべて NA に置き換える。<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;ここで示した二つの操作は &lt;code&gt;terra::crop(srtm, zion, mask = TRUE)&lt;/code&gt; と一つにまとめることもできる。理解しやすくするために二つに分けた。&lt;/p&gt;"><sup>27</sup></a></p>
<div class="sourceCode" id="cb207"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">srtm_cropped</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/crop.html">crop</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion</span><span class="op">)</span></span>
<span><span class="va">srtm_final</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/mask.html">mask</a></span><span class="op">(</span><span class="va">srtm_cropped</span>, <span class="va">zion</span><span class="op">)</span></span></code></pre></div>
<p><code><a href="https://rspatial.github.io/terra/reference/mask.html">mask()</a></code> の設定を変更すると、異なる結果が得られる。
<code>inverse = TRUE</code> を設定すると、公園の境界の<u>内側</u>をすべてマスクする (詳細は <code><a href="https://rspatial.github.io/terra/reference/mask.html">?mask</a></code> を参照) (Figure <a href="raster-vector.html#fig:cropmask">6.1</a> (D))。また、<code>updatevalue = 0</code> を設定すると、国立公園外のすべてのピクセルが 0 に設定される。</p>
<div class="sourceCode" id="cb208"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">srtm_inv_masked</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/mask.html">mask</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion</span>, inverse <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:cropmask"></span>
<img src="figures/cropmask-1.png" alt="ラスタクロップ、ラスタマスク。" width="100%"><p class="caption">
FIGURE 6.1: ラスタクロップ、ラスタマスク。
</p>
</div>
</div>
<div id="raster-extraction" class="section level2" number="6.3">
<h2>
<span class="header-section-number">6.3</span> ラスタ抽出<a class="anchor" aria-label="anchor" href="#raster-extraction"><i class="fas fa-link"></i></a>
</h2>
<p>
ラスタ抽出は、地理的 (通常はベクタ) な「範囲選択」オブジェクトに基づいて、特定の位置の「ターゲット」ラスタに関連する値を識別して返す処理である。
結果は、使用する範囲選択の種類 (点、線、ポリゴン) と、<code><a href="https://rspatial.github.io/terra/reference/extract.html">terra::extract()</a></code> 関数に渡される引数に依存する。
ラスタ抽出の逆、つまりベクタオブジェクトに基づいてラスタセル値を割り当てるのがラスタ化で、Section <a href="raster-vector.html#rasterization">6.4</a> で説明する。</p>
<p>
基本的な例として、ラスタセルの特定の<strong>点</strong>の値を抽出してみよう。
そのために、Zion 国立公園内の 30 カ所のサンプルを収録した <code>zion_points</code> を使用する (Figure <a href="raster-vector.html#fig:pointextr">6.2</a>)。
次のコマンドは、<code>srtm</code> から標高値を抽出し、各ポイントの ID (ベクタの行ごとに 1 つの値) と関連する <code>srtm</code> の値を含むデータフレームを作成する。
さて、出来上がったオブジェクトを <code><a href="https://rdrr.io/r/base/cbind.html">cbind()</a></code> 関数で <code>zion_points</code> データセットに追加してみよう。</p>
<div class="sourceCode" id="cb209"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"zion_points"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">elevation</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion_points</span><span class="op">)</span></span>
<span><span class="va">zion_points</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">zion_points</span>, <span class="va">elevation</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:pointextr"></span>
<img src="figures/pointextr-1.png" alt="ラスタ抽出に使用した点の位置。" width="100%"><p class="caption">
FIGURE 6.2: ラスタ抽出に使用した点の位置。
</p>
</div>
<p>
ラスタ抽出は、<strong>線</strong>範囲選択でも機能する。
そして、線に接するラスタセルごとに 1 つの値を抽出する。
しかし、抽出されたラスタ値の各ペア間の距離を正しく取得することが難しいため、線の断片に沿った値を得るための線抽出アプローチは推奨されていない。</p>
<p>この場合、線を多くの点に分割し、その点の値を抽出するのが良い方法である。
これを示すために、以下のコードでは、Figure <a href="raster-vector.html#fig:lineextr">6.3</a> (A) に示した Zion 国立公園の北西から南東に向かう直線、<code>zion_transect</code> を作成する (ベクタデータモデルについての復習は Section <a href="spatial-class.html#vector-data">2.2</a> を参照)。</p>
<div class="sourceCode" id="cb210"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_transect</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">113.2</span>, <span class="op">-</span><span class="fl">112.9</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">37.45</span>, <span class="fl">37.2</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_linestring</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span>crs <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">srtm</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf</a></span><span class="op">(</span>geometry <span class="op">=</span> <span class="va">_</span><span class="op">)</span></span></code></pre></div>
<p>線の範囲選択から高さを抽出することの有用性は、ハイキングの計画を立てることを想像してみるとよくわかる。
以下に示す方法は、ルートの「標高プロファイル」を提供し (線は直線である必要はない)、長い上り坂による所要時間を見積もるのに便利である。</p>
<p>まず、各断片に固有の <code>id</code> を追加する。
次に、<code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_segmentize()</a></code> 関数を使って、与えられた密度 (<code>dfMaxLength</code>) で線に沿って点を追加し、<code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> で点に変換することができる。</p>
<div class="sourceCode" id="cb211"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_transect</span><span class="op">$</span><span class="va">id</span> <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/dimensions.html">nrow</a></span><span class="op">(</span><span class="va">zion_transect</span><span class="op">)</span></span>
<span><span class="va">zion_transect</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_segmentize</a></span><span class="op">(</span><span class="va">zion_transect</span>, dfMaxLength <span class="op">=</span> <span class="fl">250</span><span class="op">)</span></span>
<span><span class="va">zion_transect</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">zion_transect</span>, <span class="st">"POINT"</span><span class="op">)</span></span></code></pre></div>
<p>これで大きな点の集合ができたので、断片の最初の点と、それ以降の各点との距離を導き出してみたい。
このケースでは、1 つの断片しかないが、原理的には、このコードはいくつの断片でも動作するはずである。</p>
<div class="sourceCode" id="cb212"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_transect</span> <span class="op">=</span> <span class="va">zion_transect</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">id</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_distance</a></span><span class="op">(</span><span class="va">geometry</span><span class="op">)</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span> </span></code></pre></div>
<p>最後に、断片の各ポイントの標高値を抽出し、この情報をメインオブジェクトに結合する。</p>
<div class="sourceCode" id="cb213"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_elev</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="va">zion_transect</span><span class="op">)</span></span>
<span><span class="va">zion_transect</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">zion_transect</span>, <span class="va">zion_elev</span><span class="op">)</span></span></code></pre></div>
<p>その結果、<code>zion_transect</code>、Figure <a href="raster-vector.html#fig:lineextr">6.3</a> (B) に示すように、標高プロファイルを作成することができる。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:lineextr"></span>
<img src="figures/lineextr-1.png" alt="ラスタ抽出に使用した線の位置 (A) と、その線に沿った標高 (B)。" width="100%"><p class="caption">
FIGURE 6.3: ラスタ抽出に使用した線の位置 (A) と、その線に沿った標高 (B)。
</p>
</div>
<p>
ラスタ抽出のための地理ベクタオブジェクトの最後のタイプは、<strong>ポリゴン</strong>である。
線と同様に、ポリゴンも 1 ポリゴンあたり多くのラスタ値を返す傾向がある。
これは以下のコマンドで示され、<code>ID</code> (ポリゴンの行番号) と <code>srtm</code> (関連する標高値) の列名を持つデータフレームが生成される。</p>
<div class="sourceCode" id="cb214"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_srtm_values</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">srtm</span>, y <span class="op">=</span> <span class="va">zion</span><span class="op">)</span></span></code></pre></div>
<p>このような結果を利用して、ポリゴンごとのラスタ値の要約統計量を生成することで、例えば、単一の地域を特徴付けることや、多くの地域を比較することができる。
これは以下のコードで示されている。このコードは、Zion 国立公園の標高値の要約統計を含むオブジェクト <code>zion_srtm_df</code> を作成する (Figure <a href="raster-vector.html#fig:polyextr">6.4</a> (A) を参照)。</p>
<div class="sourceCode" id="cb215"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">zion_srtm_values</span>, <span class="va">ID</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarize</a></span><span class="op">(</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/across.html">across</a></span><span class="op">(</span><span class="va">srtm</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>min <span class="op">=</span> <span class="va">min</span>, mean <span class="op">=</span> <span class="va">mean</span>, max <span class="op">=</span> <span class="va">max</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 1 × 4</span></span>
<span><span class="co">#&gt;      ID srtm_min srtm_mean srtm_max</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1122     1818.     2661</span></span></code></pre></div>
<p>上のコードチャンクは、Chapter <a href="attr.html#attr">3</a> で説明されているように、ポリゴン ID ごとのセル値の要約統計を提供するために <strong>dplyr</strong> を使用した。
その結果、例えば公園の最高標高が海抜約 2,661 m であることなど、有用な要約が得られる (標準偏差など、他の要約統計もこの方法で計算できる)。
この例ではポリゴンが 1 つしかないので 1 行のデータフレームだが、複数の範囲選択ポリゴンが使用されている場合にも動作する。</p>
<p>同様のアプローチは、ポリゴン内のカテゴリ的なラスタ値の出現をカウントする場合にも有効である。
これは、Figure <a href="raster-vector.html#fig:polyextr">6.4</a> (B) の <strong>spDataLarge</strong> パッケージの土地被覆データセット (<code>nlcd</code>) を使って説明され、以下のコードで実証されている。</p>
<div class="sourceCode" id="cb216"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nlcd</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/nlcd.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">zion2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">zion</span>, <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">nlcd</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">zion_nlcd</span> <span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">nlcd</span>, <span class="va">zion2</span><span class="op">)</span></span>
<span><span class="va">zion_nlcd</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">ID</span>, <span class="va">levels</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/count.html">count</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 7 × 3</span></span>
<span><span class="co">#&gt; # Groups:   ID, levels [7]</span></span>
<span><span class="co">#&gt;      ID levels         n</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1 Developed   4205</span></span>
<span><span class="co">#&gt; 2     1 Barren     98285</span></span>
<span><span class="co">#&gt; 3     1 Forest    298299</span></span>
<span><span class="co">#&gt; 4     1 Shrubland 203701</span></span>
<span><span class="co">#&gt; # ℹ 3 more rows</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:polyextr"></span>
<img src="figures/polyextr-1.png" alt="(A) 連続 と (B) カテゴリのラスタ抽出に使用した範囲。" width="100%"><p class="caption">
FIGURE 6.4: (A) 連続 と (B) カテゴリのラスタ抽出に使用した範囲。
</p>
</div>
<p>
<strong>terra</strong> パッケージはポリゴン内のラスタ値を高速に抽出するが、<code><a href="https://rspatial.github.io/terra/reference/extract.html">extract()</a></code> は大きなポリゴンデータセットを処理する際のボトルネックになることがある。
<strong>exactextractr</strong> パッケージは、<code>exact_extract()</code> 関数を通してピクセル値を抽出するための <a href="https://github.com/geocompx/geocompr/issues/813">高速の代替手段</a>を提供する。
また、<code>exact_extract()</code> 関数は、デフォルトで、ポリゴンによってオーバーラップされた各ラスタセルの割合を計算し、より正確である (詳細については、以下の注を参照)。</p>

<div class="rmdnote">
ポリゴンは通常不規則な形状をしているため、ラスタのセルの一部にしか重ならないことがある。
より詳細な結果を得るために、<code><a href="https://rspatial.github.io/terra/reference/extract.html">terra::extract()</a></code> 関数には <code>exact</code> と呼ばれる引数がある。
<code>exact = TRUE</code> とすると、出力データフレームに <code>fraction</code> という列が追加され、ポリゴンによってカバーされる各セルの割合を表す。
これは例えば、連続ラスタの加重平均や、カテゴリラスタのより正確なカバレッジを計算するのに便利である。
デフォルトでは、この操作はより多くの計算を必要とするため、<code>FALSE</code> に設定されている。
<code><a href="https://isciences.gitlab.io/exactextractr/reference/exact_extract.html">exactextractr::exact_extract()</a></code> 関数は、常に各セルにおけるポリゴンの被覆率を計算する。
</div>
</div>
<div id="rasterization" class="section level2" number="6.4">
<h2>
<span class="header-section-number">6.4</span> ラスタ化<a class="anchor" aria-label="anchor" href="#rasterization"><i class="fas fa-link"></i></a>
</h2>
<p>
ラスタ化とは、ベクタオブジェクトをラスタオブジェクトに変換して表現することである。
通常、出力されたラスタは定量的な解析 (地形の解析など) やモデリングに利用される。
Chapter <a href="spatial-class.html#spatial-class">2</a> で見たように、手法によってはラスタデータモデルの方が適していることがある。
さらに、ラスタ化は地理的なデータ集計の一種と考えることができ、結果として得られる値はすべて同じ空間分解能を持つため、データセットを簡素化することができる。</p>
<p><strong>terra</strong> パッケージには、この作業を行うための関数 <code><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize()</a></code> が含まれている。
その最初の 2 つの引数は、ラスタ化されるベクタオブジェクト <code>x</code> とテンプレートラスタ <code>y</code>である。後者は、出力の範囲、解像度、CRS を定義するラスタである。
入力ラスタの地理的解像度が低すぎる (セルサイズが大きすぎる) と、ベクタデータの地理的変動を完全に見逃す可能性があり、高すぎる場合は計算時間がかかりすぎる可能性がある。
適切な地理的解像度を決定する際に従うべき単純なルールはなく、結果の使用目的によって大きく左右される。
例えば、ラスタ化の出力を他の既存ラスタに合わせる必要がある場合など、ターゲット解像度がユーザーに課されることがよくある。</p>
<p>
ラスタ化を実演するために、入力ベクタデータ <code>cycle_hire_osm_projected</code> (ロンドンの自転車レンタルポイントに関するデータセットを Figure <a href="raster-vector.html#fig:vector-rasterization1">6.5</a> (A) に図示) と同じ範囲と CRS、空間解像度 1000 メートルのテンプレートラスタを使用することにする。</p>
<div class="sourceCode" id="cb217"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cycle_hire_osm</span> <span class="op">=</span> <span class="fu">spData</span><span class="fu">::</span><span class="va"><a href="https://jakubnowosad.com/spData/reference/cycle_hire_osm.html">cycle_hire_osm</a></span></span>
<span><span class="va">cycle_hire_osm_projected</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">cycle_hire_osm</span>, <span class="st">"EPSG:27700"</span><span class="op">)</span></span>
<span><span class="va">raster_template</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/ext.html">ext</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span><span class="op">)</span>, resolution <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>                       crs <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>ラスタ化は非常に柔軟な操作で、結果はテンプレートとなるラスタの性質だけでなく、入力ベクタの種類 (点、ポリゴンなど) や、<code><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize()</a></code> 関数が取るさまざまな引数に依存する。</p>
<p>この柔軟性を説明するために、3 つの異なるアプローチでラスタ化を試みる。
まず、レンタルサイクルの有無を表すラスタ (有無ラスタと呼ぶ) を作成する。
この場合、<code><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize()</a></code> は、<code>x</code> と <code>y</code> (前述のベクタとラスタのオブジェクト) のみを要求する (図示の結果 Figure <a href="raster-vector.html#fig:vector-rasterization1">6.5</a> (B))。</p>
<div class="sourceCode" id="cb218"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ch_raster1</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span>, <span class="va">raster_template</span><span class="op">)</span></span></code></pre></div>
<p><code>fun</code> 引数は、近接した複数の観測値をラスタオブジェクトの関連セルに変換するために使用される要約統計量を指定する。
デフォルトでは、<code>fun = "last"</code> が使用されるが、<code>fun = "length"</code> などの他のオプションも使用できる。この場合、各グリッドセル内のレンタルサイクルのステーション数をカウントする (この操作の結果は、Figure <a href="raster-vector.html#fig:vector-rasterization1">6.5</a> (C) に示す)。</p>
<div class="sourceCode" id="cb219"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ch_raster2</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span>, <span class="va">raster_template</span>, </span>
<span>                       fun <span class="op">=</span> <span class="st">"length"</span><span class="op">)</span></span></code></pre></div>
<p>新しい出力である <code>ch_raster2</code> は、各グリッドセル内のレンタルサイクルのステーション数を示している。
レンタルサイクルのステーションは、<code>capacity</code> 変数で記述される自転車の数が異なるため、各グリッドセルの収容台数 (<code>capacity</code>) はどの程度なのかという疑問が生じる。
これを計算するためには、フィールド (<code>"capacity"</code>) を <code>sum</code> することが必要で、その結果、Figure <a href="raster-vector.html#fig:vector-rasterization1">6.5</a> (D) のような出力が得られる。以下のコマンドで計算する (<code>mean</code> など他の要約関数も使用できる)。</p>
<div class="sourceCode" id="cb220"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ch_raster3</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/vect.html">vect</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span><span class="op">)</span>, <span class="va">raster_template</span>, </span>
<span>                       field <span class="op">=</span> <span class="st">"capacity"</span>, fun <span class="op">=</span> <span class="va">sum</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vector-rasterization1"></span>
<img src="figures/vector-rasterization1-1.png" alt="点のラスタ化例。" width="100%"><p class="caption">
FIGURE 6.5: 点のラスタ化例。
</p>
</div>
<p>
また、カリフォルニア州のポリゴンと境界線をベースにしたデータセット (下記作成) は、線のラスタ化を表している。
ポリゴンオブジェクトを複合線にキャストした後、0.5 度の分解能を持つテンプレートラスタを作成する。</p>
<div class="sourceCode" id="cb221"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">california</span> <span class="op">=</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">us_states</span>, <span class="va">NAME</span> <span class="op">==</span> <span class="st">"California"</span><span class="op">)</span></span>
<span><span class="va">california_borders</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">california</span>, <span class="st">"MULTILINESTRING"</span><span class="op">)</span></span>
<span><span class="va">raster_template2</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/ext.html">ext</a></span><span class="op">(</span><span class="va">california</span><span class="op">)</span>, resolution <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                        crs <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">california</span><span class="op">)</span><span class="op">$</span><span class="va">wkt</span><span class="op">)</span></span></code></pre></div>
<p>線またはポリゴンのラスタ化を考慮する場合、有用な追加引数の 1 つは <code>touches</code> である。
デフォルトでは <code>FALSE</code> であるが、<code>TRUE</code> に変更すると、線またはポリゴンの境界で接触しているすべてのセルが値を得る。
<code>touches = TRUE</code> による線のラスタ化を以下のコードで実行する (Figure <a href="raster-vector.html#fig:vector-rasterization2">6.6</a> (A))。</p>
<div class="sourceCode" id="cb222"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">california_raster1</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize</a></span><span class="op">(</span><span class="va">california_borders</span>, <span class="va">raster_template2</span>,</span>
<span>                               touches <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>ポリゴンのラスタ化と比較すると、<code>touches = FALSE</code> がデフォルトで、Figure <a href="raster-vector.html#fig:vector-rasterization2">6.6</a> (B) に示すように、範囲選択ポリゴン内に中心点があるラスタセルのみが選択されることになる。</p>
<div class="sourceCode" id="cb223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">california_raster2</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rasterize.html">rasterize</a></span><span class="op">(</span><span class="va">california</span>, <span class="va">raster_template2</span><span class="op">)</span> </span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vector-rasterization2"></span>
<img src="figures/vector-rasterization2-1.png" alt="線とポリゴンのラスタ化の例。" width="100%"><p class="caption">
FIGURE 6.6: 線とポリゴンのラスタ化の例。
</p>
</div>
</div>
<div id="spatial-vectorization" class="section level2" number="6.5">
<h2>
<span class="header-section-number">6.5</span> 空間ベクタ化<a class="anchor" aria-label="anchor" href="#spatial-vectorization"><i class="fas fa-link"></i></a>
</h2>
<p>
空間ベクタ化は、ラスタ化 (Section <a href="raster-vector.html#rasterization">6.4</a>) と対で、方向が逆になる。
空間的に連続したラスタデータを、点、線、ポリゴンなどの空間的に離散したベクタデータに変換する。</p>

<div class="rmdnote">
表現に注意。
R では通常、単にベクトル化と言った場合、<code>for</code> ループなどを <code>1:10 / 2</code> のように置き換えることができるようにすることを指す (<span class="citation">Wickham (<a href="references.html#ref-wickham_advanced_2019">2019</a>)</span> 参照)。
</div>
<p>
最も単純なベクタ化は、ラスタセルの中心を点に変換することである。
<code><a href="https://rspatial.github.io/terra/reference/as.points.html">as.points()</a></code> は、<code>NA</code> 以外のすべてのラスタグリッドセルに対して実行する (Figure <a href="raster-vector.html#fig:raster-vectorization1">6.7</a>)。
なお、ここでは、<code><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf()</a></code> を使って、結果のオブジェクトを <code>sf</code> クラスに変換することもしている。</p>
<div class="sourceCode" id="cb224"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elev</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/elev.tif"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">elev_point</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/as.points.html">as.points</a></span><span class="op">(</span><span class="va">elev</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:raster-vectorization1"></span>
<img src="figures/raster-vectorization1-1.png" alt="elev オブジェクトのラスタ表現と点表現。" width="100%"><p class="caption">
FIGURE 6.7: elev オブジェクトのラスタ表現と点表現。
</p>
</div>
<p>
空間ベクタ化のもう一つの一般的なタイプは、例えば連続した高さや温度の線 (等温線) を表す等高線の作成である。
ここでは、実世界のデジタル標高モデル (DEM) を使用する。というのも、人工のラスタ <code>elev</code> は平行線を生成するためである (読者への課題: これを検証し、なぜこうなるのかを説明しなさい)。
等高線は <strong>terra</strong> 関数 <code><a href="https://rspatial.github.io/terra/reference/contour.html">as.contour()</a></code> で作成することができる。この関数は、R に元々ある <code><a href="https://rdrr.io/r/graphics/filled.contour.html">filled.contour()</a></code> のラッパーである (図示せず)。</p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dem</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/dem.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">cl</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/contour.html">as.contour</a></span><span class="op">(</span><span class="va">dem</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">dem</span>, axes <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">cl</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><code><a href="https://rspatial.github.io/terra/reference/contour.html">contour()</a></code> や <code>rasterVis::contourplot()</code> などの関数で、既存のプロットに等高線を追加することもできる。
<!--`tmap::tm_iso() -->
Figure <a href="raster-vector.html#fig:contour-tmap">6.8</a> に示すように、等値線 (isoline) にはラベルを付けることができる。</p>
<p></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:contour-tmap"></span>
<img src="images/06-contour-tmap.png" alt="モンゴル山南麓の等高線を重ねた陰影付きデジタル標高モデル。" width="100%"><p class="caption">
FIGURE 6.8: モンゴル山南麓の等高線を重ねた陰影付きデジタル標高モデル。
</p>
</div>
<p>
ベクタ化の最後のタイプとして、ラスタをポリゴンに変換しよう。
これには、<code><a href="https://rspatial.github.io/terra/reference/as.polygons.html">terra::as.polygons()</a></code> を使う。各ラスタセルを 5 つの座標からなるポリゴンに変換し、そのすべてがメモリに保存される (ラスタがベクタと比較して高速であることが多い理由が分かる!)。</p>
<p>以下では、<code>grain</code> オブジェクトをポリゴンに変換し、その後、同じ属性値を持つポリゴン間の境界を解消することで説明している (<code><a href="https://rspatial.github.io/terra/reference/as.polygons.html">as.polygons()</a></code> の <code>dissolve</code> の引数も参照)。</p>
<div class="sourceCode" id="cb226"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">grain</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/grain.tif"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">grain_poly</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/as.polygons.html">as.polygons</a></span><span class="op">(</span><span class="va">grain</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:06-raster-vector-40"></span>
<img src="figures/06-raster-vector-40-1.png" alt="ラスタ (A)のベクタ化 (B) ポリゴン (dissolve = FALSE; 中央) と融合ポリゴン (dissolve = TRUE)。" width="100%"><p class="caption">
FIGURE 6.9: ラスタ (A)のベクタ化 (B) ポリゴン (dissolve = FALSE; 中央) と融合ポリゴン (dissolve = TRUE)。
</p>
</div>
<p><code>grain</code> データセットのポリゴンは、長方形のピクセルをつなぐことで定義される直方体の境界を持つ。
ポリゴンを滑らか (smooth) にするために、Chapter <a href="geometry-operations.html#geometry-operations">5</a> のパッケージ <strong>smoothr</strong> を使用することができる。
平滑化処理はポリゴン境界の鋭いエッジを除去するため、平滑化ポリゴンは元のピクセルとは空間的範囲が正確に同じにはならない。
そのため、平滑化されたポリゴンをさらに解析に使用する場合は注意が必要となる。</p>
</div>
<div id="演習-4" class="section level2" number="6.6">
<h2>
<span class="header-section-number">6.6</span> 演習<a class="anchor" aria-label="anchor" href="#%E6%BC%94%E7%BF%92-4"><i class="fas fa-link"></i></a>
</h2>
<p>以下の演習では、<strong>spDataLarge</strong> パッケージのベクタデータ (<code>zion_points</code>) とラスタデータ (<code>srtm</code>) を使うことがある。
まず、ベクタデータ (<code>ch</code>) から、ポリゴンの「凸多面体」で領域を示す。</p>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/">terra</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://jakubnowosad.com/spData/">spData</a></span><span class="op">)</span></span>
<span><span class="va">zion_points_path</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"vector/zion_points.gpkg"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">zion_points</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf</a></span><span class="op">(</span><span class="va">zion_points_path</span><span class="op">)</span></span>
<span><span class="va">srtm</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ch</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_combine</a></span><span class="op">(</span><span class="va">zion_points</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_convex_hull</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>E1. <code>srtm</code> ラスタを、 (1) <code>zion_points</code>と (2) <code>ch</code> のデータセットを使い切り落とし (crop) なさい。
作成した地図に違いはあるか？
次に、同じデータセットを使い <code>srtm</code> をマスクしなさい。
何か違いはあるか?
その違いを説明できるか?</p>
<p>E2. まず、<code>zion_points</code> で表される点の <code>srtm</code> から値を抽出しなさい。
次に、<code>zion_points</code> の各点を 90 個のバッファで囲んで <code>srtm</code> の平均値を抽出し、この 2 つの値を比較しなさい。
バッファによる値の抽出は、点のみによる抽出よりもどのような場合に適しているだろうか?</p>
<ul>
<li>ボーナス: <strong>exactextractr</strong>パッケージを使用して抽出を実行し、結果を比較しなさい。</li>
</ul>
<p>E3. New Zealand の標高 3100 m 以上のポイント (<code>nz_height</code>オブジェクト) の部分集合を作成し、新しい点データセットの範囲に対して解像度 3 km のテンプレートラスタを作成しなさい。
これら 2 つの新しいオブジェクトを使い、</p>
<ul>
<li>各グリッドセルで最も標高の高い点の数を数えなさい。</li>
<li>各グリッドセル内の最大標高を求めなさい。</li>
</ul>
<p>E4. New Zealand の高地の位置を数えるラスタ (前のエクササイズで作成) を集約し、その地理的解像度を半分に下げ (セルが 6 * 6 km になるように)、結果をプロットしなさい。</p>
<ul>
<li>低解像度のラスタを元の解像度 3 km に再サンプルしなさい。結果はどう変わったか?</li>
<li>ラスタの解像度を下げることの利点と欠点を 2 つ挙げなさい。</li>
</ul>
<p>E5. <code>grain</code> データセットをポリゴンにして、土を表している正方形をフィルタしなさい。</p>
<ul>
<li>ベクタデータがラスタデータよりも良い点と悪い点を挙げなさい。</li>
<li>ラスタをベクタに変換すると良いのはどのような時か？</li>
</ul>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="geometry-operations.html"><span class="header-section-number">5</span> ジオメトリ演算</a></div>
<div class="next"><a href="reproj-geo-data.html"><span class="header-section-number">7</span> 地理データの再投影</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Second Edition</h2>
    <!--<p>Now is a great time to provide feedback</p>-->
        <ul class="list-unstyled">
<!--<li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Provide feedback (5 min)</a></li>--><li><a href="https://geocompx.org/">Visit the geocompx website 🌐</a></li>
          <li><a href="https://r.geocompx.org/#reproducibility">Install updated packages 💾</a></li>
          <li><a href="https://github.com/geocompx/geocompr/issues">Open an issue <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Chat on Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://r.geocompx.org/solutions/">Check exercise solutions <i class="fa fa-check"></i></a></li>
          <li><a href="https://supportukrainenow.org/">Support Ukraine 🇺🇦
</a></li>
          <li><a href="https://donate.stripe.com/4gweWl94Q9E35AQ6oo">Support this project 💸</a></li>
        </ul>
<div class="LECTURE_IN_JAPANESE" style="border:solid 1px;border-color:#be1558;background:#fbcbc9"><a href="https://peatix.com/group/16401222" target="_blank">2025年4月頃より、レクチャーを計画しています。Peatix でフォローしてください。</a></div>
        <hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#raster-vector"><span class="header-section-number">6</span> ラスタとベクタの相互作用</a></li>
<li><a class="nav-link" href="#prerequisites-06">必須パッケージ</a></li>
<li><a class="nav-link" href="#introduction-06"><span class="header-section-number">6.1</span> イントロダクション</a></li>
<li><a class="nav-link" href="#raster-cropping"><span class="header-section-number">6.2</span> ラスタの切り落とし (crop)</a></li>
<li><a class="nav-link" href="#raster-extraction"><span class="header-section-number">6.3</span> ラスタ抽出</a></li>
<li><a class="nav-link" href="#rasterization"><span class="header-section-number">6.4</span> ラスタ化</a></li>
<li><a class="nav-link" href="#spatial-vectorization"><span class="header-section-number">6.5</span> 空間ベクタ化</a></li>
<li><a class="nav-link" href="#%E6%BC%94%E7%BF%92-4"><span class="header-section-number">6.6</span> 演習</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompx/geocompr/blob/main/06-raster-vector-ja.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompx/geocompr/edit/main/06-raster-vector-ja.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation with R</strong>" was written by Robin Lovelace, Jakub Nowosad, Jannes Muenchow. It was last built on 2025-06-10.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
